This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.husky/
  commit-msg
  pre-commit
src/
  auth/
    application/
      services/
        __tests__/
          requestOtpService.test.ts
          verifyOtpService.test.ts
        requestOtpService.ts
        verifyOtpService.ts
    domain/
      errors/
        otpLoginError.ts
        userLoginErrors.ts
      helpers/
        validators/
          hashValidator.ts
          verificationCodeValidator.ts
      interfaces/
        generators/
          CodeGenerator.ts
          HashGenerator.ts
          TokenGenerator.ts
        repositories/
          OtpRepository.ts
          TokenRepository.ts
        validators/
          PhoneValidator.ts
      model/
        __tests__/
          otp.test.ts
        Otp.ts
        UserAuth.ts
    infrastructure/
      __tests__/
        loginFlow.test.ts
      database/
        repositories/
          SQLiteOtpRepository.ts
          SQLiteTokenRepository.ts
      endpoints/
        requestOtp/
          __tests__/
            e2e/
              requestOtp.test.ts
            integration/
              requestOtp.test.ts
          errors.ts
          requestOtp.ts
          schema.ts
        verifyOtp/
          __tests__/
            e2e/
              verifyOtp.test.ts
            integration/
              verifyOtp.test.ts
          errors.ts
          schema.ts
          verifyOtp.ts
      helpers/
        generators/
          fromHashTokenGenerator.ts
          randomCodeGenerator.ts
          randomHashGenerator.ts
        validators/
          blacklistPhoneValidator.ts
      http/
        authenticate.ts
  common/
    domain/
      helpers/
        validators/
          ninValidator.ts
          phoneValidator.ts
      model/
        TokenUser.ts
        UserParameters.ts
    infrastructure/
      database/
        seeders/
          userSeeder.ts
        createTables.ts
        dbClient.ts
        initDatabase.ts
        initTestDatabase.ts
        schema.ts
      endpoints/
        errorSchema.ts
        routes.ts
      helpers/
        extractBearer.ts
      server/
        index.ts
        serverBuild.ts
  user/
    application/
      services/
        __tests__/
          getProfileService.test.ts
        getProfileService.ts
        updateProfileService.ts
    domain/
      helpers/
        emailValidator.ts
      interfaces/
        repositories/
          UserRespository.ts
      model/
        UserProfile.ts
    infrastructure/
      database/
        repositories/
          SQLiteUserRepository.ts
      endpoints/
        getProfile/
          __tests__/
            e2e/
              getProfile.test.ts
            integration/
              getProfile.test.ts
          getProfile.ts
          schema.ts
        updateProfile/
          schema.ts
          updateProfile.ts
.commitlintrc.js
.dockerignore
.env.example
.gitignore
.prettierrc
docker-compose.yml
Dockerfile
eslint.config.cjs
jest.config.js
Makefile
package.json
README.md
tsconfig.build.json
tsconfig.editor.json
tsconfig.jest.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".dockerignore">
node_modules
npm-debug.log
yarn-error.log
.git
.gitignore
dist
*.log
logs/
data
.env
</file>

<file path=".prettierrc">
{
  "semi": true,
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "trailingComma": "all",
  "arrowParens": "always",
  "endOfLine": "lf"
}
</file>

<file path=".husky/commit-msg">
#!/usr/bin/env sh
npx --no -- commitlint --edit "$1"
</file>

<file path="src/auth/domain/helpers/validators/hashValidator.ts">
const HASH_FORMAT = new RegExp(/^[a-f0-9]{64}$/i);
export function invalidHash(hash: string): boolean {
  return !HASH_FORMAT.test(hash);
}
</file>

<file path="src/auth/domain/helpers/validators/verificationCodeValidator.ts">
const VERIFICATION_CODE_FORMAT = new RegExp(/^[0-9]{6}$/);
export function invalidVerificationCode(verificationCode: string): boolean {
  return !VERIFICATION_CODE_FORMAT.test(verificationCode);
}
</file>

<file path="src/auth/domain/interfaces/generators/HashGenerator.ts">
import { Hash } from '../../model/Otp';

export interface HashGenerator {
  generateHash(): Hash;
}
</file>

<file path="src/auth/domain/model/UserAuth.ts">
import { Nin, UserId } from '@common/domain/model/UserParameters';
export type IsBlocked = boolean;
export interface UserAuth {
  id: UserId;
  nin: Nin;
  isBlocked: IsBlocked;
}
</file>

<file path="src/auth/infrastructure/http/authenticate.ts">
import fp from 'fastify-plugin';
import { extractBearer } from '@common/infrastructure/helpers/extractBearer';
import { tokenRepository } from '@auth/infrastructure/database/repositories/SQLiteTokenRepository';

declare module 'fastify' {
  interface FastifyRequest {
    userId?: number;
  }
}

export default fp(async (fastify) => {
  fastify.decorateRequest<number | undefined>('userId', undefined);

  fastify.addHook('preHandler', async (req, reply) => {
    const token = extractBearer(req.headers.authorization ?? '');
    if (!token) {
      return reply.code(401).send({ error: 'Unauthorized.' });
    }

    const userId = await tokenRepository.getUserIdByToken(token);
    if (userId === null || userId === undefined) {
      return reply.code(401).send({ error: 'Unauthorized.' });
    }

    req.userId = userId;
  });
});
</file>

<file path="src/common/domain/helpers/validators/ninValidator.ts">
const DNI_FORMAT = new RegExp(/^[0-9]{8}[a-zA-Z]$/);
const NIE_FORMAT = new RegExp(/^[XYZxyz]\d{7}[a-zA-Z]$/);
const CIF_FORMAT = new RegExp(/^([ABCDEFGHJKLMNPQRSUVWabcdefghjklmnpqrsuvw])(\d{7})([0-9A-Ja-j])$/);
export function isValidNin(nin: string): boolean {
  return DNI_FORMAT.test(nin) || NIE_FORMAT.test(nin) || CIF_FORMAT.test(nin);
}
</file>

<file path="src/common/domain/helpers/validators/phoneValidator.ts">
const PHONE_FORMAT = new RegExp(/^\+?\d{9,11}$/);
export function isValidPhone(phone: string): boolean {
  return PHONE_FORMAT.test(phone);
}
</file>

<file path="src/common/domain/model/TokenUser.ts">
export type TokenUser = string;
</file>

<file path="src/common/domain/model/UserParameters.ts">
export type Phone = string;
export type Nin = string;
export type UserId = number;
</file>

<file path="src/common/infrastructure/database/dbClient.ts">
import { Kysely, SqliteDialect } from 'kysely';
import Database from 'better-sqlite3';
import { Database as DBTypes } from './schema';
import 'dotenv/config';

const getDbFilePath = () => {
  if (process.env.NODE_ENV === 'test') {
    return ':memory:';
  }
  return process.env.DATABASE_FILE_PATH;
};

const db = new Kysely<DBTypes>({
  dialect: new SqliteDialect({
    database: new Database(getDbFilePath()),
  }),
});

export default db;
</file>

<file path="src/common/infrastructure/database/initDatabase.ts">
import { createTables } from './createTables';
import { seedUser } from './seeders/userSeeder';
import fs from 'fs';

const createDataDirectory = async () => {
  if (!fs.existsSync('./data')) {
    fs.mkdirSync('./data', { recursive: true });
  }
};

async function initDatabase() {
  try {
    await createDataDirectory();
    await createTables();
    await seedUser();
  } catch (error) {
    console.error('Error inicializando la base de datos:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  initDatabase();
}
</file>

<file path="src/common/infrastructure/database/initTestDatabase.ts">
import { createTables } from './createTables';
import { seedUser } from './seeders/userSeeder';

export async function initTestDatabase() {
  try {
    await createTables();
    await seedUser();
  } catch (error) {
    console.error('Error inicializando la base de datos de test:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  initTestDatabase();
}
</file>

<file path="src/common/infrastructure/endpoints/errorSchema.ts">
export const errorSchema = {
  type: 'object',
  properties: {
    error: { type: 'string' },
  },
  required: ['error'],
};
</file>

<file path="src/common/infrastructure/endpoints/routes.ts">
import { FastifyInstance } from 'fastify';

import requestOtp from '@auth/infrastructure/endpoints/requestOtp/requestOtp';
import verifyOtp from '@auth/infrastructure/endpoints/verifyOtp/verifyOtp';
import { otpRepository } from '@auth/infrastructure/database/repositories/SQLiteOtpRepository';
import { codeGenerator } from '@auth/infrastructure/helpers/generators/randomCodeGenerator';
import { hashGenerator } from '@auth/infrastructure/helpers/generators/randomHashGenerator';
import { phoneValidator } from '@auth/infrastructure/helpers/validators/blacklistPhoneValidator';
import { tokenGenerator } from '@auth/infrastructure/helpers/generators/fromHashTokenGenerator';
import { tokenRepository } from '@auth/infrastructure/database/repositories/SQLiteTokenRepository';

import registerUpdateProfile from '@user/infrastructure/endpoints/updateProfile/updateProfile';
import registerGetProfile from '@user/infrastructure/endpoints/getProfile/getProfile';
import { userRepository } from '@user/infrastructure/database/repositories/SQLiteUserRepository';

import authenticateUser from '@auth/infrastructure/http/authenticate';
export function registerRoutes(fastify: FastifyInstance) {
  // --- AUTH ---
  fastify.register(
    requestOtp({
      otpRepository,
      userRepository,
      codeGenerator,
      hashGenerator,
      phoneValidator,
    }),
  );

  fastify.register(
    verifyOtp({
      tokenRepository,
      otpRepository,
      tokenGenerator,
    }),
  );

  // --- USER ---
  fastify.register(async (app) => {
    app.register(authenticateUser);
    app.register(registerGetProfile());
    app.register(registerUpdateProfile());
  });
}
</file>

<file path="src/common/infrastructure/helpers/extractBearer.ts">
export function extractBearer(authHeader: string): string | null {
  const m = /^Bearer\s+(.+)$/.exec(authHeader);
  return m?.[1] ?? null;
}
</file>

<file path="src/common/infrastructure/server/index.ts">
import { build, start } from './serverBuild';

const fastify = build();
export default fastify;
if (require.main === module) {
  const PORT = 3000;
  start(fastify, PORT);
}
</file>

<file path="src/user/application/services/__tests__/getProfileService.test.ts">
import {
  getProfileService,
  userNotFoundErrorStatusMsg,
} from '@user/application/services/getProfileService';
import { UserRepository } from '@user/domain/interfaces/repositories/UserRespository';
import { UserProfile } from '@user/domain/model/UserProfile';

describe('getProfileService', () => {
  beforeEach(() => jest.resetAllMocks());

  test('should return the user profile when user exists', async () => {
    const userId = 1;
    const profile: UserProfile = {
      id: userId,
      fullName: 'Usuario Uno',
      nin: '87654321Z',
      email: 'user1@example.com',
    };

    const mockRepo: UserRepository = {
      getUser: jest.fn(),
      isUserPhoneRegistered: jest.fn(),
      getProfile: jest.fn(async () => profile),
    };

    await expect(getProfileService(mockRepo, { userId })).resolves.toEqual(profile);
    expect(mockRepo.getProfile).toHaveBeenCalledWith(userId);
  });

  test('should return USER_NOT_FOUND when repo returns null', async () => {
    const userId = 99;

    const mockRepo: UserRepository = {
      getUser: jest.fn(),
      isUserPhoneRegistered: jest.fn(),
      getProfile: jest.fn(async () => null),
    };

    await expect(getProfileService(mockRepo, { userId })).resolves.toBe(userNotFoundErrorStatusMsg);
    expect(mockRepo.getProfile).toHaveBeenCalledWith(userId);
  });
});
</file>

<file path="src/user/application/services/updateProfileService.ts">
import { UserProfile } from '@user/domain/model/UserProfile';
import { UserRepository } from '@user/domain/interfaces/repositories/UserRespository';

export const successfulStatusMsg = 'SUCCESSFUL' as const;
export const userNotFoundErrorStatusMsg = 'USER_NOT_FOUND' as const;
export const emptyPatchErrorStatusMsg = 'EMPTY_PATCH' as const;

type UpdateProfileInput = {
  userId: number;
  data: Partial<Pick<UserProfile, 'fullName' | 'nin' | 'email'>>;
};

export type UpdateProfileServiceResult =
  | typeof successfulStatusMsg
  | typeof userNotFoundErrorStatusMsg
  | typeof emptyPatchErrorStatusMsg;

export async function updateProfileService(
  userRepository: UserRepository,
  { userId, data }: UpdateProfileInput,
): Promise<UpdateProfileServiceResult> {
  if (Object.keys(data).length === 0) {
    return emptyPatchErrorStatusMsg;
  }

  const updated = await userRepository.updateProfile(userId, data);
  return updated ? successfulStatusMsg : userNotFoundErrorStatusMsg;
}
</file>

<file path="src/user/domain/helpers/emailValidator.ts">
const EMAIL_FORMAT = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
export function isValidEmail(email: string): boolean {
  return EMAIL_FORMAT.test(email);
}
</file>

<file path="src/user/domain/model/UserProfile.ts">
import { Nin, UserId } from '@common/domain/model/UserParameters';
export type Email = string;
export type FullName = string;
export interface UserProfile {
  id: UserId;
  nin: Nin;
  email: Email;
  fullName: FullName;
}
</file>

<file path="src/user/infrastructure/endpoints/getProfile/__tests__/e2e/getProfile.test.ts">
import { FastifyInstance } from 'fastify';
import { build } from '@common/infrastructure/server/serverBuild';
import { initTestDatabase } from '@common/infrastructure/database/initTestDatabase';
import { GET_PROFILE_ENDPOINT } from '../../getProfile';
import { REQUEST_OTP_ENDPOINT } from '@auth/infrastructure/endpoints/requestOtp/requestOtp';
import { VERIFY_OTP_ENDPOINT } from '@auth/infrastructure/endpoints/verifyOtp/verifyOtp';

describe('getProfile e2e', () => {
  let app: FastifyInstance;

  beforeAll(async () => {
    app = build();
    await app.ready();
    await initTestDatabase();
  });

  afterAll(async () => {
    await app.close();
  });

  test('should return user profile for valid user (happy path)', async () => {
    const nin = '87654321Z';
    const phone = '222222222';

    const requestOtpRes = await app.inject({
      method: 'POST',
      url: REQUEST_OTP_ENDPOINT,
      payload: { nin, phone },
    });
    expect(requestOtpRes.statusCode).toBe(201);
    const { hash, verificationCode } = requestOtpRes.json();

    const verifyOtpRes = await app.inject({
      method: 'POST',
      url: VERIFY_OTP_ENDPOINT,
      payload: { hash, verificationCode },
    });
    expect(verifyOtpRes.statusCode).toBe(201);
    const { token } = verifyOtpRes.json();

    const profileRes = await app.inject({
      method: 'GET',
      url: GET_PROFILE_ENDPOINT,
      headers: { authorization: `Bearer ${token}` },
    });

    expect(profileRes.statusCode).toBe(200);
    expect(profileRes.json()).toEqual({
      id: 1,
      fullName: 'Usuario Uno',
      nin: '87654321Z',
      email: 'usuario1@example.com',
    });
  });
});
</file>

<file path="src/user/infrastructure/endpoints/getProfile/__tests__/integration/getProfile.test.ts">
import { FastifyInstance } from 'fastify';
import { build } from '@src/common/infrastructure/server/serverBuild';
import { GET_PROFILE_ENDPOINT } from '../../getProfile';
import { userRepository } from '@src/user/infrastructure/database/repositories/SQLiteUserRepository';
import { tokenRepository } from '@auth/infrastructure/database/repositories/SQLiteTokenRepository';

jest.mock('@auth/infrastructure/database/repositories/SQLiteTokenRepository', () => ({
  tokenRepository: { getUserIdByToken: jest.fn() },
}));
jest.mock('@src/user/infrastructure/database/repositories/SQLiteUserRepository', () => ({
  userRepository: { getProfile: jest.fn() },
}));

describe('getProfile integration', () => {
  let app: FastifyInstance;

  beforeAll(async () => {
    app = build();
    await app.ready();
  });

  beforeEach(async () => {
    jest.resetAllMocks();
  });

  afterAll(async () => {
    await app.close();
  });

  test('should return the user profile when token exists for a valid user', async () => {
    const token = 'valid-token';
    const userId = 1;
    const profile = {
      id: userId,
      fullName: 'Usuario Uno',
      nin: '87654321Z',
      email: 'usuario.uno@example.com',
    };

    jest.spyOn(tokenRepository, 'getUserIdByToken').mockResolvedValue(userId);
    jest.spyOn(userRepository, 'getProfile').mockResolvedValue(profile as any);

    const response = await app.inject({
      method: 'GET',
      url: GET_PROFILE_ENDPOINT,
      headers: { authorization: `Bearer ${token}` },
    });

    expect(response.statusCode).toBe(200);
    expect(response.json()).toEqual(profile);
  });

  test('should return a user not found error when token exists but user does not', async () => {
    const token = 'valid-token';
    const userId = 1;

    jest.spyOn(tokenRepository, 'getUserIdByToken').mockResolvedValue(userId);
    jest.spyOn(userRepository, 'getProfile').mockResolvedValue(null);

    const response = await app.inject({
      method: 'GET',
      url: GET_PROFILE_ENDPOINT,
      headers: { authorization: `Bearer ${token}` },
    });

    expect(response.statusCode).toBe(404);
    expect(response.json()).toEqual({ error: 'User not found.' });
  });

  test('should return a unauthorized error when token does not exist', async () => {
    const token = 'not-valid-token';

    jest.spyOn(tokenRepository, 'getUserIdByToken').mockResolvedValue(null);

    const response = await app.inject({
      method: 'GET',
      url: GET_PROFILE_ENDPOINT,
      headers: { authorization: `Bearer ${token}` },
    });

    expect(response.statusCode).toBe(401);
    expect(response.json()).toEqual({ error: 'Unauthorized.' });
  });

  test('should return bad request error when token is not introduced', async () => {
    const response = await app.inject({
      method: 'GET',
      url: GET_PROFILE_ENDPOINT,
    });

    expect(response.statusCode).toBe(400);
    const body = response.json();
    expect(body.error).toBe('Bad Request');
    expect(tokenRepository.getUserIdByToken).not.toHaveBeenCalled();
  });
});
</file>

<file path="src/user/infrastructure/endpoints/updateProfile/updateProfile.ts">
import { FastifyInstance } from 'fastify';
import { updateProfileSchema } from './schema';
import { userRepository } from '@user/infrastructure/database/repositories/SQLiteUserRepository';
import {
  updateProfileService,
  successfulStatusMsg,
  userNotFoundErrorStatusMsg,
  emptyPatchErrorStatusMsg,
} from '@user/application/services/updateProfileService';
import { UserProfile } from '@user/domain/model/UserProfile';
import { isValidNin } from '@common/domain/helpers/validators/ninValidator';
import { isValidEmail } from '@user/domain/helpers/emailValidator';

export const UPDATE_PROFILE_ENDPOINT = '/user/profile';

type UpdateProfileBody = Partial<Pick<UserProfile, 'fullName' | 'nin' | 'email'>>;

type UpdateProfileErrors =
  | typeof successfulStatusMsg
  | typeof userNotFoundErrorStatusMsg
  | typeof emptyPatchErrorStatusMsg
  | 'INVALID_PARAMETERS_FORMAT';

const statusToMessage: { [K in UpdateProfileErrors]: string | object } & {
  [key: string]: string | object;
} = {
  [successfulStatusMsg]: { message: 'Profile updated successfully.' },
  [userNotFoundErrorStatusMsg]: { error: 'User not found.' },
  [emptyPatchErrorStatusMsg]: { error: 'Missing profile parameters.' },
  INVALID_PARAMETERS_FORMAT: { error: 'Invalid parameters format.' },
};

type StatusCode = 200 | 400 | 404;

const statusToCode: { [K in UpdateProfileErrors]: StatusCode } & { [key: string]: StatusCode } = {
  [successfulStatusMsg]: 200,
  [userNotFoundErrorStatusMsg]: 404,
  [emptyPatchErrorStatusMsg]: 400,
  INVALID_PARAMETERS_FORMAT: 400,
};

interface UpdateProfileDependencies {
  userRepository: typeof userRepository;
}

function updateProfile(dependencies: UpdateProfileDependencies = { userRepository }) {
  return async function (fastify: FastifyInstance) {
    fastify.put(UPDATE_PROFILE_ENDPOINT, updateProfileSchema, async (request, reply) => {
      try {
        const userId = request.userId!;
        const body = (request.body ?? {}) as UpdateProfileBody;

        if (missingParameters(body)) {
          return reply
            .status(statusToCode[emptyPatchErrorStatusMsg])
            .send(statusToMessage[emptyPatchErrorStatusMsg]);
        }

        if (invalidParameters(body)) {
          return reply
            .status(statusToCode.INVALID_PARAMETERS_FORMAT)
            .send(statusToMessage.INVALID_PARAMETERS_FORMAT);
        }

        const result = await updateProfileService(dependencies.userRepository, {
          userId,
          data: body,
        });

        return reply.status(statusToCode[result]).send(statusToMessage[result]);
      } catch (error) {
        fastify.log.error(error);
        return reply.status(500).send({ error: 'Internal Server Error' });
      }
    });
  };
}

function missingParameters(body: UpdateProfileBody): boolean {
  return !body.fullName && !body.nin && !body.email;
}

function invalidParameters(body: UpdateProfileBody): boolean {
  if (
    body.fullName !== undefined &&
    (typeof body.fullName !== 'string' || body.fullName.trim() === '')
  ) {
    return true;
  }
  if (body.nin !== undefined && !isValidNin(body.nin)) {
    return true;
  }
  if (body.email !== undefined && !isValidEmail(body.email)) {
    return true;
  }
  return false;
}

export default updateProfile;
</file>

<file path=".gitignore">
node_modules
dist/
data/*.sqlite
*.log
.DS_Store
data
.env
</file>

<file path="eslint.config.cjs">
const tseslint = require('@typescript-eslint/eslint-plugin');
const tsParser = require('@typescript-eslint/parser');

module.exports = [
  {
    files: ['**/*.ts', '**/*.tsx'],
    languageOptions: {
      parser: tsParser,
      parserOptions: {
        ecmaVersion: 2020,
        sourceType: 'module',
        ecmaFeatures: {
          jsx: true,
        },
      },
    },
    plugins: {
      '@typescript-eslint': tseslint,
      'unused-imports': require('eslint-plugin-unused-imports'),
    },
    rules: {
      'no-console': 'warn',
      'no-debugger': 'error',
      eqeqeq: ['error', 'always'],
      curly: ['error', 'all'],
      quotes: ['error', 'single'],

      'no-unused-vars': 'off',

      '@typescript-eslint/no-unused-vars': ['warn', { argsIgnorePattern: '^_' }],

      'unused-imports/no-unused-imports': 'warn',
      'unused-imports/no-unused-vars': [
        'warn',
        { vars: 'all', varsIgnorePattern: '^_', args: 'after-used', argsIgnorePattern: '^_' },
      ],

      '@typescript-eslint/explicit-function-return-type': 'off',
      '@typescript-eslint/no-explicit-any': 'warn',
    },
  },
];
</file>

<file path="README.md">
## üêãLevantar el entorno Dockerüêã

1. Instalar Docker y Docker Desktop
2. Dejar libre el puerto 3000 (desarrollo) y 3001 (tests)
3. Levantar backend y base de datos:
   ```bash
   make up
   ```
4. Crear tablas e insertar en la base de datos:
   ```bash
   make db-init
   ```

## üß™ Entorno de Testing üß™

### Ejecutar tests con Docker (recomendado)

```bash
# Ejecutar tests una vez (cierra cuando termina)
make test

# Ejecutar tests en modo watch (deja la terminal abierta)
make test-watch
```

### Comandos adicionales de testing

```bash
# Levantar solo los servicios de test en background
make up-test

# Inicializar base de datos de test
make db-init-test

# Abrir shell en el contenedor de test
make test-shell

# Ver logs de los servicios de test
make logs-test

# Parar servicios de test
make down-test
```

### Diferencias entre entornos

- **Desarrollo**: Puerto 3000, base de datos `sequraBackendDB.sqlite` (persistente)
- **Test**: Puerto 3001, base de datos en memoria (no persistente, se reinicia en cada ejecuci√≥n)
- Los tests usan `NODE_ENV=test` autom√°ticamente
- Usa un solo archivo `docker-compose.yml` con perfiles para separar entornos
</file>

<file path="tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "exclude": [
    "node_modules",
    "dist",
    "**/__tests__/**/*",
    "**/*.test.ts",
    "**/*.spec.ts",
    "src/test-setup.ts"
  ]
}
</file>

<file path="tsconfig.editor.json">
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "baseUrl": "./src",
    "types": ["node", "jest"],
    "paths": {
      "@common/*": ["common/*"],
      "@auth/*": ["auth/*"],
      "@user/*": ["user/*"],
      "@src/*": ["./*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path=".husky/pre-commit">
#!/usr/bin/env sh
npx lint-staged
</file>

<file path="src/auth/domain/interfaces/generators/CodeGenerator.ts">
import { VerificationCode } from '../../model/Otp';

export interface CodeGenerator {
  generateSixDigitCode(): VerificationCode;
}
</file>

<file path="src/auth/infrastructure/endpoints/requestOtp/errors.ts">
import {
  UserBlockedError,
  UserNotFoundError,
  UserPhoneUnavailableError,
} from '../../../domain/errors/userLoginErrors';

export const missingNinOrPhoneErrorStatusMsg = 'MISSING_NIN_OR_PHONE' as const;
export const invalidNinOrPhoneErrorStatusMsg = 'INVALID_NIN_OR_PHONE' as const;

export type MissingNinOrPhoneError = typeof missingNinOrPhoneErrorStatusMsg;
export type InvalidNinOrPhoneError = typeof invalidNinOrPhoneErrorStatusMsg;

export type RequestOtpParameterErrors = MissingNinOrPhoneError | InvalidNinOrPhoneError;

export type RequestOtpErrors =
  | RequestOtpParameterErrors
  | UserPhoneUnavailableError
  | UserBlockedError
  | UserNotFoundError;
</file>

<file path="src/auth/infrastructure/endpoints/verifyOtp/errors.ts">
import {
  ExpiredVerificationCodeError,
  OtpNotFoundError,
} from '../../../domain/errors/otpLoginError';

export const missingHashOrCodeErrorStatusMsg = 'MISSING_HASH_OR_CODE' as const;
export const invalidHashOrCodeErrorStatusMsg = 'INVALID_HASH_OR_CODE' as const;

export type MissingHashOrCodeError = typeof missingHashOrCodeErrorStatusMsg;
export type InvalidHashOrCodeError = typeof invalidHashOrCodeErrorStatusMsg;

export type VerifyOtpParameterErrors = MissingHashOrCodeError | InvalidHashOrCodeError;

export type VerifyOtpErrors =
  | VerifyOtpParameterErrors
  | OtpNotFoundError
  | ExpiredVerificationCodeError;
</file>

<file path="src/auth/infrastructure/helpers/generators/randomHashGenerator.ts">
import crypto from 'crypto';
import { HashGenerator } from '../../../domain/interfaces/generators/HashGenerator';

export const hashGenerator: HashGenerator = {
  generateHash: () => {
    return crypto.randomBytes(32).toString('hex');
  },
};
</file>

<file path="src/common/infrastructure/database/seeders/userSeeder.ts">
// src/common/infrastructure/database/seeders/userSeeder.ts
import db from '../dbClient';

export async function seedUser() {
  const users = getUsers();

  for (const { nin, phones, isBlocked, fullName, email } of users) {
    const userExists = await selectUser(nin);

    if (!userExists) {
      await insertUserAndPhones(nin, phones, isBlocked, fullName, email);
    }
  }
}

function getUsers() {
  return [
    {
      nin: '87654321Z',
      phones: ['222222222', '888888888'],
      isBlocked: false,
      fullName: 'Usuario Uno',
      email: 'usuario1@example.com',
    },
    {
      nin: '12345678A',
      phones: ['666666666', '777777777'],
      isBlocked: false,
      fullName: 'Usuario Dos',
      email: 'usuario2@example.com',
    },
    {
      nin: '12345678B',
      phones: ['111111111', '111111121'],
      isBlocked: false,
      fullName: 'Usuario Tres',
      email: 'usuario3@example.com',
    },
    {
      nin: '87654321A',
      phones: ['666666667'],
      isBlocked: true,
      fullName: 'Usuario Bloqueado',
      email: 'bloqueado@example.com',
    },
  ];
}

async function selectUser(nin: string) {
  return await db.selectFrom('user').select('nin').where('nin', '=', nin).executeTakeFirst();
}

async function insertUserAndPhones(
  nin: string,
  phones: string[],
  isBlocked: boolean,
  fullName: string,
  email: string,
) {
  const inserted = await db
    .insertInto('user')
    .values({
      nin,
      isBlocked: (isBlocked ? 1 : 0) as unknown as boolean,
      fullName,
      email,
    })
    .returning(['id'])
    .executeTakeFirst();

  if (inserted?.id) {
    const phoneInserts = phones.map((phoneNumber) => ({
      userId: inserted.id,
      phoneNumber,
    }));

    await db.insertInto('phone').values(phoneInserts).execute();
  }
}
</file>

<file path="src/common/infrastructure/database/createTables.ts">
import { sql } from 'kysely';
import db from './dbClient';

export const createTables = async () => {
  await sql`
  CREATE TABLE IF NOT EXISTS phone (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      phoneNumber TEXT NOT NULL,
      userId INTEGER NOT NULL,
      FOREIGN KEY (userId) REFERENCES user(id)
  );
`.execute(db);

  await sql`
    CREATE TABLE IF NOT EXISTS user (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        nin TEXT NOT NULL,
        isBlocked BOOLEAN NOT NULL,
        fullName TEXT NOT NULL,
        email TEXT NOT NULL
    );
  `.execute(db);

  await sql`
    CREATE TABLE IF NOT EXISTS otp (
        userId INTEGER PRIMARY KEY, -- PK y FK
        hash TEXT NOT NULL,
        verificationCode TEXT NOT NULL,
        expirationDate TEXT NOT NULL,
        FOREIGN KEY (userId) REFERENCES user(id)
    );
  `.execute(db);

  await sql`
    CREATE TABLE IF NOT EXISTS token (
        userId INTEGER PRIMARY KEY, -- PK y FK
        token TEXT NOT NULL,
        FOREIGN KEY (userId) REFERENCES user(id)
    );
  `.execute(db);
};
</file>

<file path="src/user/infrastructure/endpoints/getProfile/schema.ts">
import { errorSchema } from '@common/infrastructure/endpoints/errorSchema';

export const getProfileSchema = {
  schema: {
    headers: {
      type: 'object',
      properties: {
        authorization: {
          type: 'string',
          description: 'Bearer token',
        },
      },
      required: ['authorization'],
    },
    response: {
      200: {
        type: 'object',
        properties: {
          id: { type: 'number' },
          fullName: { type: 'string' },
          nin: { type: 'string' },
          email: { type: 'string' },
        },
        required: ['id', 'fullName', 'nin', 'email'],
      },
      400: errorSchema,
      401: errorSchema,
      404: errorSchema,
      500: errorSchema,
    },
  },
};
</file>

<file path="src/user/infrastructure/endpoints/updateProfile/schema.ts">
import { errorSchema } from '@common/infrastructure/endpoints/errorSchema';

export const updateProfileSchema = {
  schema: {
    headers: {
      type: 'object',
      properties: {
        authorization: { type: 'string', description: 'Bearer token' },
      },
    },
    body: {
      type: 'object',
      properties: {
        fullName: { type: 'string', maxLength: 100 },
        nin: { type: 'string' },
        email: { type: 'string', maxLength: 100 },
      },
      additionalProperties: false,
    },
    response: {
      200: {
        type: 'object',
        properties: {
          message: { type: 'string' },
        },
        required: ['message'],
      },
      400: errorSchema,
      401: errorSchema,
      404: errorSchema,
      500: errorSchema,
    },
  },
};
</file>

<file path=".commitlintrc.js">
const headerPattern = /^\[#\d*\] - .{1,80}$/;

module.exports = {
  rules: {
    'header-pattern': (parsed) => {
      if (!parsed || !parsed.header) {
        return [false, 'commit header is missing'];
      }
      if (!headerPattern.test(parsed.header)) {
        return [false, `header must match pattern ${headerPattern.toString()}`];
      }
      return [true];
    },
    'header-pattern': [2, 'always'],
    'header-max-length': [2, 'always', 80],
  },
  plugins: [
    {
      rules: {
        'header-pattern': (parsed) => {
          if (!parsed || !parsed.header) {
            return [false, 'commit header is missing'];
          }
          if (!headerPattern.test(parsed.header)) {
            return [false, `header must match pattern ${headerPattern.toString()}`];
          }
          return [true];
        },
      },
    },
  ],
};
</file>

<file path=".env.example">
# Database configuration
DATABASE_FILE_PATH=./data/sequraBackendDB.sqlite

# Environment
NODE_ENV=development

# Note: Tests use in-memory database automatically when NODE_ENV=test
</file>

<file path="src/auth/domain/errors/otpLoginError.ts">
export const otpNotFoundErrorStatusMsg = 'OTP_NOT_FOUND' as const;
export const expiredVerificationCodeErrorStatusMsg = 'EXPIRED_VERIFICATION_CODE' as const;

export type OtpNotFoundError = typeof otpNotFoundErrorStatusMsg;
export type ExpiredVerificationCodeError = typeof expiredVerificationCodeErrorStatusMsg;
</file>

<file path="src/auth/domain/errors/userLoginErrors.ts">
export const userBlockedErrorStatusMsg = 'USER_BLOCKED' as const;
export const userNotFoundErrorStatusMsg = 'USER_NOT_FOUND' as const;
export const userPhoneUnavailableForSmsErrorStatusMsg = 'UNAVAILABLE_PHONE' as const;

export type UserPhoneUnavailableError = typeof userPhoneUnavailableForSmsErrorStatusMsg;
export type UserBlockedError = typeof userBlockedErrorStatusMsg;
export type UserNotFoundError = typeof userNotFoundErrorStatusMsg;
</file>

<file path="src/auth/domain/interfaces/generators/TokenGenerator.ts">
import { Hash } from '../../model/Otp';
import { TokenUser } from '@common/domain/model/TokenUser';

export interface TokenGenerator {
  generateToken(hash: Hash): TokenUser;
}
</file>

<file path="src/auth/domain/interfaces/validators/PhoneValidator.ts">
import { Phone } from '@common/domain/model/UserParameters';

export interface PhoneValidator {
  validatePhone(phone: Phone): boolean;
}
</file>

<file path="src/auth/infrastructure/database/repositories/SQLiteOtpRepository.ts">
import db from '@common/infrastructure/database/dbClient';
import { Hash, VerificationCode, Otp } from '../../../domain/model/Otp';
import { OtpRepository } from '../../../domain/interfaces/repositories/OtpRepository';
import { UserId } from '@common/domain/model/UserParameters';

export const otpRepository: OtpRepository = {
  saveOtp,
  getOtp,
  deleteOtp,
};

async function saveOtp(otp: Otp) {
  const existing = await db
    .selectFrom('otp')
    .select('userId')
    .where('userId', '=', otp.userId)
    .executeTakeFirst();

  if (existing) {
    await db
      .updateTable('otp')
      .set({
        hash: otp.hash,
        verificationCode: otp.verificationCode,
        expirationDate: otp.expirationDate,
      })
      .where('userId', '=', otp.userId)
      .execute();
  } else {
    await db
      .insertInto('otp')
      .values({
        userId: otp.userId,
        hash: otp.hash,
        verificationCode: otp.verificationCode,
        expirationDate: otp.expirationDate,
      })
      .execute();
  }
}

async function getOtp(verificationCode: VerificationCode, hash: Hash) {
  const otpRow = await db
    .selectFrom('otp')
    .selectAll()
    .where('verificationCode', '=', verificationCode)
    .where('hash', '=', hash)
    .executeTakeFirst();
  if (!otpRow) {
    return null;
  }
  return otpRow;
}
async function deleteOtp(userId: UserId) {
  await db.deleteFrom('otp').where('userId', '=', userId).execute();
}
</file>

<file path="src/auth/infrastructure/endpoints/verifyOtp/__tests__/e2e/verifyOtp.test.ts">
import { FastifyInstance } from 'fastify';
import { build } from '@common/infrastructure/server/serverBuild';
import { VERIFY_OTP_ENDPOINT } from '../../verifyOtp';
import { createTables } from '@common/infrastructure/database/createTables';
import { seedUser } from '@common/infrastructure/database/seeders/userSeeder';
import {
  ExpirationDate,
  generateOtpExpirationDate,
  Hash,
  Otp,
  VerificationCode,
} from '../../../../../domain/model/Otp';
import { codeGenerator } from '../../../../helpers/generators/randomCodeGenerator';
import { hashGenerator } from '../../../../helpers/generators/randomHashGenerator';
import { otpRepository } from '../../../../database/repositories/SQLiteOtpRepository';

jest.mock('../../../../../domain/model/Otp', () => ({
  ...jest.requireActual('../../../../../domain/model/Otp'),
  isOtpExpired: jest.fn(() => false),
}));

describe('verifyOtp', () => {
  let app: FastifyInstance;

  beforeAll(async () => {
    app = build();
    await app.ready();
    if (process.env.NODE_ENV === 'test') {
      try {
        await createTables();
        await seedUser();
      } catch (error) {
        throw error;
      }
    }
  });

  beforeEach(async () => {
    jest.resetAllMocks();
  });

  afterAll(async () => {
    await app.close();
  });

  test('should return a token when introducing a correct nin and phone number', async () => {
    const hash: Hash = hashGenerator.generateHash();
    const verificationCode: VerificationCode = codeGenerator.generateSixDigitCode();
    const expirationDateString: ExpirationDate = generateOtpExpirationDate();
    const otp: Otp = {
      userId: 1,
      verificationCode: verificationCode,
      hash: hash,
      expirationDate: expirationDateString,
    };

    await otpRepository.saveOtp(otp);

    const verifyOtpResponse = await app.inject({
      method: 'POST',
      url: VERIFY_OTP_ENDPOINT,
      payload: { hash, verificationCode },
    });

    expect(verifyOtpResponse.statusCode).toBe(201);
    expect(verifyOtpResponse.json()).toHaveProperty('token');
    expect(verifyOtpResponse.json().token).not.toBe('');
  });
});
</file>

<file path="src/auth/infrastructure/endpoints/verifyOtp/__tests__/integration/verifyOtp.test.ts">
import { FastifyInstance } from 'fastify';
import { build } from '@common/infrastructure/server/serverBuild';
import { otpRepository } from '../../../../database/repositories/SQLiteOtpRepository';
import { tokenGenerator } from '../../../../helpers/generators/fromHashTokenGenerator';
import { VERIFY_OTP_ENDPOINT } from '../../verifyOtp';
import { tokenRepository } from '../../../../database/repositories/SQLiteTokenRepository';
import { isOtpExpired } from '../../../../../domain/model/Otp';

jest.mock('../../../../../domain/model/Otp', () => ({
  ...jest.requireActual('../../../../../domain/model/Otp'),
  isOtpExpired: jest.fn(() => false),
}));

describe('verifyOtp', () => {
  let app: FastifyInstance;

  beforeAll(async () => {
    app = build();
    await app.ready();
  });

  beforeEach(async () => {
    jest.resetAllMocks();
  });

  afterAll(async () => {
    await app.close();
  });

  test('should return a token when introducing a correct hash and verification code', async () => {
    const userId = 1;
    const hash = '9d2bff5d9dfdacfaa4a39e2a6d7f98ea5bd89f5d311986a50f24ee542ba9e221';
    const verificationCode = '123456';
    const token = 'token';
    const expirationDate = 'notExpiredDate';

    const getOtpSpy = jest.spyOn(otpRepository, 'getOtp').mockResolvedValue({
      userId,
      verificationCode,
      hash,
      expirationDate,
    });

    (isOtpExpired as jest.Mock).mockReturnValue(false);
    jest.spyOn(otpRepository, 'deleteOtp').mockResolvedValue();
    jest.spyOn(tokenGenerator, 'generateToken').mockReturnValue(token);
    jest.spyOn(tokenRepository, 'saveToken').mockResolvedValue();

    const response = await app.inject({
      method: 'POST',
      url: VERIFY_OTP_ENDPOINT,
      payload: { hash: hash, verificationCode: verificationCode },
    });
    const data = response.json();

    expect(response.statusCode).toBe(201);
    expect(data).toHaveProperty('token');
    expect(data.token).toBe(token);
    expect(getOtpSpy).toHaveBeenCalledWith(verificationCode, hash);
    expect(isOtpExpired).toHaveBeenCalledWith({
      userId,
      verificationCode,
      hash,
      expirationDate,
    });
  });

  test('should return missing hash or verification code error when introducing an empty hash', async () => {
    const hash = '';
    const verificationCode = '123456';

    const response = await app.inject({
      method: 'POST',
      url: VERIFY_OTP_ENDPOINT,
      payload: { hash: hash, verificationCode: verificationCode },
    });
    const data = response.json();

    expect(response.statusCode).toBe(400);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Missing hash or verification code.');
  });

  test('should return missing hash or verification code error when introducing an empty verification code', async () => {
    const hash = '9d2bff5d9dfdacfaa4a39e2a6d7f98ea5bd89f5d311986a50f24ee542ba9e221';
    const verificationCode = '';

    const response = await app.inject({
      method: 'POST',
      url: VERIFY_OTP_ENDPOINT,
      payload: { hash: hash, verificationCode: verificationCode },
    });
    const data = response.json();

    expect(response.statusCode).toBe(400);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Missing hash or verification code.');
  });

  test('should return missing hash or verification code error when introducing no body', async () => {
    const response = await app.inject({
      method: 'POST',
      url: VERIFY_OTP_ENDPOINT,
      payload: {},
    });
    const data = response.json();

    expect(response.statusCode).toBe(400);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Missing hash or verification code.');
  });

  test('should return invalid hash or verification code error when hash has improper format', async () => {
    const hash = 'hash';
    const verificationCode = '123456';

    const response = await app.inject({
      method: 'POST',
      url: VERIFY_OTP_ENDPOINT,
      payload: { hash: hash, verificationCode: verificationCode },
    });
    const data = response.json();

    expect(response.statusCode).toBe(400);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Invalid hash or verification code.');
  });

  test('should return invalid hash or verification code error when verification code has improper format', async () => {
    const hash = '9d2bff5d9dfdacfaa4a39e2a6d7f98ea5bd89f5d311986a50f24ee542ba9e221';
    const verificationCode = 'verification code';

    const response = await app.inject({
      method: 'POST',
      url: VERIFY_OTP_ENDPOINT,
      payload: { hash: hash, verificationCode: verificationCode },
    });
    const data = response.json();

    expect(response.statusCode).toBe(400);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Invalid hash or verification code.');
  });

  test('should return incorrect hash or verification code error when introducing incorrect parameters', async () => {
    const hash = '9d2bff5d9dfdacfaa4a39e2a6d7f98ea5bd89f5d311986a50f24ee542ba9e221';
    const verificationCode = '123456';
    const getOtpSpy = jest.spyOn(otpRepository, 'getOtp').mockResolvedValue(null);

    const response = await app.inject({
      method: 'POST',
      url: VERIFY_OTP_ENDPOINT,
      payload: { hash: hash, verificationCode: verificationCode },
    });
    const data = response.json();

    expect(response.statusCode).toBe(401);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Incorrect hash or verification code.');
    expect(getOtpSpy).toHaveBeenCalledWith(verificationCode, hash);
  });

  test('should return incorrect hash or verification code error when the verification code is expired', async () => {
    const userId = 1;
    const hash = '9d2bff5d9dfdacfaa4a39e2a6d7f98ea5bd89f5d311986a50f24ee542ba9e221';
    const verificationCode = '123456';
    const expirationDate = new Date(Date.now() - 1000).toISOString();
    const getOtpSpy = jest.spyOn(otpRepository, 'getOtp').mockResolvedValue({
      userId,
      verificationCode,
      hash,
      expirationDate,
    });
    jest.spyOn(otpRepository, 'deleteOtp').mockResolvedValue();
    (isOtpExpired as jest.Mock).mockReturnValue(true);

    const response = await app.inject({
      method: 'POST',
      url: VERIFY_OTP_ENDPOINT,
      payload: { hash: hash, verificationCode: verificationCode },
    });
    const data = response.json();

    expect(response.statusCode).toBe(401);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Incorrect hash or verification code.');
    expect(getOtpSpy).toHaveBeenCalledWith(verificationCode, hash);
    expect(isOtpExpired).toHaveBeenCalledWith({
      userId,
      verificationCode,
      hash,
      expirationDate,
    });
  });

  test('should return internal server error when the database malfunctions', async () => {
    const hash = '9d2bff5d9dfdacfaa4a39e2a6d7f98ea5bd89f5d311986a50f24ee542ba9e221';
    const verificationCode = '123456';

    jest.spyOn(otpRepository, 'getOtp').mockRejectedValue(new Error('Database error'));

    const response = await app.inject({
      method: 'POST',
      url: VERIFY_OTP_ENDPOINT,
      payload: { hash: hash, verificationCode: verificationCode },
    });
    const data = response.json();

    expect(response.statusCode).toBe(500);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Internal Server Error');
  });
});
</file>

<file path="src/auth/infrastructure/helpers/generators/randomCodeGenerator.ts">
import { CodeGenerator } from '../../../domain/interfaces/generators/CodeGenerator';
import { VerificationCode } from '../../../domain/model/Otp';

export const codeGenerator: CodeGenerator = {
  generateSixDigitCode: (): VerificationCode => {
    let result: VerificationCode;

    result = '';
    for (let i = 0; i < 6; i++) {
      const randomIndex = Math.floor(Math.random() * 10);
      result += randomIndex.toString();
    }

    return result;
  },
};
</file>

<file path="src/common/infrastructure/server/serverBuild.ts">
import Fastify, { FastifyInstance } from 'fastify';
import swagger from '@fastify/swagger';
import swaggerUI from '@fastify/swagger-ui';
import { registerRoutes } from '../endpoints/routes';

export function build(): FastifyInstance {
  const app = Fastify({
    logger: {
      transport: {
        target: 'pino-pretty',
        options: {
          colorize: true,
          translateTime: 'SYS:standard',
          ignore: 'pid,hostname',
        },
      },
    },
  });

  registerSwagger(app);
  registerSwaggerUI(app);
  registerRoutes(app);

  return app;
}

function registerSwagger(app: FastifyInstance) {
  app.register(swagger, {
    swagger: {
      info: {
        title: 'SeQura Backend',
        version: '1.0.0',
      },
    },
  });
}

function registerSwaggerUI(app: FastifyInstance) {
  app.register(swaggerUI, {
    routePrefix: '/docs',
    uiConfig: {
      docExpansion: 'full',
      deepLinking: false,
    },
    staticCSP: true,
    transformSpecification: (swaggerObject) => {
      return swaggerObject;
    },
    transformSpecificationClone: true,
  });
}

export const start = async (fastify: FastifyInstance, PORT: number) => {
  try {
    await fastify.listen({ port: PORT, host: '0.0.0.0' });
    console.log(`Server listening on http://0.0.0.0:${PORT}`);
  } catch (err) {
    console.error('Error starting server:', err);
    fastify.log.error(err);
    process.exit(1);
  }
};
</file>

<file path="src/user/application/services/getProfileService.ts">
import { UserProfile } from '@user/domain/model/UserProfile';
import { UserRepository } from '@user/domain/interfaces/repositories/UserRespository';

export const userNotFoundErrorStatusMsg = 'USER_NOT_FOUND' as const;

type GetProfileInput = { userId: number };
type GetProfileResponse = UserProfile;
export type GetProfileServiceErrors = typeof userNotFoundErrorStatusMsg;

export async function getProfileService(
  userRepository: UserRepository,
  { userId }: GetProfileInput,
): Promise<GetProfileServiceErrors | GetProfileResponse> {
  const profile = await userRepository.getProfile(userId);
  return profile ?? userNotFoundErrorStatusMsg;
}
</file>

<file path="src/user/domain/interfaces/repositories/UserRespository.ts">
import { UserAuth } from '@auth/domain/model/UserAuth';
import { Phone, Nin, UserId } from '@common/domain/model/UserParameters';
import { UserProfile } from '@src/user/domain/model/UserProfile';

export interface UserRepository {
  getUser(nin: Nin): Promise<UserAuth | null>;
  getProfile(userId: UserId): Promise<UserProfile | null>;
  updateProfile(
    userId: UserId,
    patch: Partial<Pick<UserProfile, 'fullName' | 'nin' | 'email'>>,
  ): Promise<boolean>;
  isUserPhoneRegistered(userId: UserId, phone: Phone): Promise<boolean>;
}
</file>

<file path="src/user/infrastructure/database/repositories/SQLiteUserRepository.ts">
import db from '@common/infrastructure/database/dbClient';
import { Phone, Nin, UserId } from '@common/domain/model/UserParameters';
import { UserRepository } from '../../../domain/interfaces/repositories/UserRespository';
import { UserAuth } from '@auth/domain/model/UserAuth';
import { UserProfile } from '@src/user/domain/model/UserProfile';

export const userRepository: UserRepository = {
  async getUser(nin: Nin): Promise<UserAuth | null> {
    const row = await db.selectFrom('user').selectAll().where('nin', '=', nin).executeTakeFirst();
    if (!row) {
      return null;
    }
    return { id: row.id, nin: row.nin, isBlocked: Boolean(row.isBlocked) };
  },

  async getProfile(userId: UserId): Promise<UserProfile | null> {
    const row = await db.selectFrom('user').selectAll().where('id', '=', userId).executeTakeFirst();
    if (!row) {
      return null;
    }
    return { id: row.id, fullName: row.fullName, nin: row.nin, email: row.email };
  },

  async isUserPhoneRegistered(userId: UserId, phone: Phone): Promise<boolean> {
    const phoneMatch = await db
      .selectFrom('phone')
      .select('id')
      .where('userId', '=', userId)
      .where('phoneNumber', '=', phone)
      .executeTakeFirst();
    return !!phoneMatch;
  },

  async updateProfile(
    userId: UserId,
    patch: Partial<Pick<UserProfile, 'fullName' | 'nin' | 'email'>>,
  ): Promise<boolean> {
    const { fullName, nin, email } = patch;

    if (!fullName && !nin && !email) {
      return false;
    }

    const updates: Record<string, unknown> = {};
    if (fullName) {
      updates.fullName = fullName;
    }
    if (nin) {
      updates.nin = nin;
    }
    if (email) {
      updates.email = email;
    }

    const result = await db
      .updateTable('user')
      .set(updates)
      .where('id', '=', userId)
      .executeTakeFirst();

    return !!result;
  },
};
</file>

<file path="tsconfig.jest.json">
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",
    "baseUrl": "./src",
    "types": ["node", "jest"],
    "paths": {
      "@common/*": ["common/*"],
      "@auth/*": ["auth/*"],
      "@user/*": ["user/*"],
      "@src/*": ["./*"]
    }
  },
  "include": ["src/**/*", "src/**/__tests__/**/*", "src/**/*.test.ts", "src/**/*.spec.ts"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="src/auth/domain/interfaces/repositories/OtpRepository.ts">
import { Hash, Otp, VerificationCode } from '../../model/Otp';
import { UserId } from '@common/domain/model/UserParameters';

export interface OtpRepository {
  saveOtp(otp: Otp): Promise<void>;
  getOtp(verificationCode: VerificationCode, hash: Hash): Promise<Otp | null>;
  deleteOtp(userId: UserId): Promise<void>;
}
</file>

<file path="src/auth/infrastructure/__tests__/loginFlow.test.ts">
import { FastifyInstance } from 'fastify';
import { build } from '@common/infrastructure/server/serverBuild';
import { initTestDatabase } from '@common/infrastructure/database/initTestDatabase';
import { VERIFY_OTP_ENDPOINT } from '../endpoints/verifyOtp/verifyOtp';
import { REQUEST_OTP_ENDPOINT } from '../endpoints/requestOtp/requestOtp';

describe('loginFlow', () => {
  let app: FastifyInstance;

  beforeAll(async () => {
    app = build();
    await app.ready();
    try {
      await initTestDatabase();
    } catch (error) {
      console.error('Error setting up test database:', error);
      throw error;
    }
  });

  beforeEach(async () => {
    jest.resetAllMocks();
  });

  afterAll(async () => {
    await app.close();
  });

  test('should complete the full login process with correct credentials', async () => {
    const nin = '87654321Z';
    const phone = '222222222';

    const requestOtpResponse = await app.inject({
      method: 'POST',
      url: REQUEST_OTP_ENDPOINT,
      payload: { nin, phone },
    });

    const { hash, verificationCode } = requestOtpResponse.json();
    expect(requestOtpResponse.statusCode).toBe(201);
    expect(requestOtpResponse.json()).toHaveProperty('hash');
    expect(requestOtpResponse.json()).toHaveProperty('verificationCode');
    expect(hash).not.toBe('');
    expect(verificationCode).not.toBe('');

    const verifyOtpResponse = await app.inject({
      method: 'POST',
      url: VERIFY_OTP_ENDPOINT,
      payload: { hash, verificationCode },
    });

    expect(verifyOtpResponse.statusCode).toBe(201);
    expect(verifyOtpResponse.json()).toHaveProperty('token');
    expect(verifyOtpResponse.json().token).not.toBe('');
  });
});
</file>

<file path="src/auth/infrastructure/endpoints/requestOtp/__tests__/e2e/requestOtp.test.ts">
import { FastifyInstance } from 'fastify';
import { build } from '@common/infrastructure/server/serverBuild';
import { initTestDatabase } from '@common/infrastructure/database/initTestDatabase';
import { REQUEST_OTP_ENDPOINT } from '../../requestOtp';

describe('requestOtp', () => {
  let app: FastifyInstance;

  beforeAll(async () => {
    app = build();
    await app.ready();
    try {
      await initTestDatabase();
    } catch (error) {
      console.error('Error setting up test database:', error);
      throw error;
    }
  });

  beforeEach(async () => {
    jest.resetAllMocks();
  });

  afterAll(async () => {
    await app.close();
  });

  test('should return hash and verification code for correct nin and phone', async () => {
    const nin = '87654321Z';
    const phone = '222222222';

    const response = await app.inject({
      method: 'POST',
      url: REQUEST_OTP_ENDPOINT,
      payload: { nin, phone },
    });

    expect(response.statusCode).toBe(201);

    const data = response.json();
    expect(data).toEqual(
      expect.objectContaining({
        verificationCode: expect.any(String),
        hash: expect.any(String),
      }),
    );
  });
});
</file>

<file path="src/auth/infrastructure/endpoints/requestOtp/schema.ts">
import { errorSchema } from '@common/infrastructure/endpoints/errorSchema';

export const requestOtpSchema = {
  schema: {
    body: {
      type: 'object',
      properties: {
        nin: { type: 'string' },
        phone: { type: 'string' },
      },
      additionalProperties: false,
    },
    response: {
      201: {
        type: 'object',
        properties: {
          hash: { type: 'string' },
          verificationCode: { type: 'string' },
        },
        required: ['hash', 'verificationCode'],
      },
      400: errorSchema,
      401: errorSchema,
      403: errorSchema,
      500: errorSchema,
    },
  },
};
</file>

<file path="src/auth/infrastructure/endpoints/verifyOtp/schema.ts">
import { errorSchema } from '../../../../common/infrastructure/endpoints/errorSchema';

export const verifyOtpSchema = {
  schema: {
    body: {
      type: 'object',
      properties: {
        hash: { type: 'string' },
        verificationCode: { type: 'string' },
      },
      additionalProperties: false,
    },
    response: {
      201: {
        type: 'object',
        properties: {
          token: { type: 'string' },
        },
        required: ['token'],
      },
      400: errorSchema,
      401: errorSchema,
      500: errorSchema,
    },
  },
};
</file>

<file path="src/auth/infrastructure/helpers/generators/fromHashTokenGenerator.ts">
import { TokenGenerator } from '../../../domain/interfaces/generators/TokenGenerator';
import { Hash } from '../../../domain/model/Otp';
import { TokenUser } from '@common/domain/model/TokenUser';
import crypto from 'crypto';

export const tokenGenerator: TokenGenerator = {
  generateToken: (hash: Hash): TokenUser => {
    return crypto.createHash('sha256').update(hash).digest('hex');
  },
};
</file>

<file path="docker-compose.yml">
services:
  backend:
    build: .
    container_name: sequra-backend
    ports:
      - '${BACKEND_PORT:-3000}:3000'
    volumes:
      - .:/app
      - /app/node_modules
      - ./data:/app/data
    depends_on:
      - db
    environment:
      - NODE_ENV=${NODE_ENV:-development}
      - DATABASE_FILE_PATH=${DATABASE_FILE_PATH:-./data/sequraBackendDB.sqlite}
    command: >
      sh -c "npm ci &&
             if [ \"$NODE_ENV\" = \"development\" ]; then
               npm run dev;
             else
               npm run build && ${BACKEND_COMMAND:-node dist/common/infrastructure/server/index.js};
             fi"
    profiles:
      - production
      - test
      - development

  db:
    image: nouchka/sqlite3
    container_name: sequra-db
    volumes:
      - ./data:/app/data
    stdin_open: true
    tty: true
    platform: linux/amd64

volumes:
  sqlite_data:
</file>

<file path="Dockerfile">
FROM node:20-alpine
WORKDIR /app

RUN apk add --no-cache \
    sqlite \
    python3 \
    make \
    g++ \
    git \
    && apk upgrade --no-cache

COPY package*.json ./
RUN npm install

COPY . .

RUN npm run build

EXPOSE 3000

CMD ["node", "dist/common/infrastructure/server/index.js"]
</file>

<file path="src/auth/domain/model/__tests__/otp.test.ts">
import { FastifyInstance } from 'fastify';
import { build } from '@common/infrastructure/server/serverBuild';
import { generateOtpExpirationDate, isOtpExpired } from '../Otp';

describe('Otp', () => {
  let app: FastifyInstance;

  beforeAll(async () => {
    app = build();
    await app.ready();
  });

  beforeEach(() => {
    jest.useFakeTimers().setSystemTime(0);
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  afterAll(async () => {
    await app.close();
  });

  test('should return a five minute expiration date when generating an otp expiration date', () => {
    const fiveMinutesInMilliseconds = 1000 * 60 * 5;

    const result = generateOtpExpirationDate();

    const expectedDate = new Date(fiveMinutesInMilliseconds).toISOString();
    expect(result).toBe(expectedDate);
  });

  test('should return false when checking if an otp whose expiration date is in the future is expired', () => {
    const fiveMinutesInMilliseconds = 1000 * 60 * 5;
    const otp = {
      userId: 1,
      verificationCode: '123456',
      hash: 'hash',
      expirationDate: new Date(fiveMinutesInMilliseconds).toISOString(),
    };

    jest.advanceTimersByTime(1000);
    const result = isOtpExpired(otp);
    expect(result).toBe(false);
  });

  test('should return true when checking if an otp whose expiration date is in the past is expired', () => {
    const fiveMinutesInMilliseconds = 1000 * 60 * 5;
    const otp = {
      userId: 1,
      verificationCode: '123456',
      hash: 'hash',
      expirationDate: new Date(0).toISOString(),
    };

    jest.advanceTimersByTime(fiveMinutesInMilliseconds);
    const result = isOtpExpired(otp);
    expect(result).toBe(true);
  });

  test('should return true when checking if an otp whose expiration date is not a date is expired', () => {
    const fiveMinutesInMilliseconds = 1000 * 60 * 5;
    const otp = {
      userId: 1,
      verificationCode: '123456',
      hash: 'hash',
      expirationDate: 'notADate',
    };

    jest.advanceTimersByTime(fiveMinutesInMilliseconds);
    const result = isOtpExpired(otp);
    expect(result).toBe(true);
  });
});
</file>

<file path="src/auth/domain/model/Otp.ts">
import { UserId } from '@common/domain/model/UserParameters';

export type VerificationCode = string;
export type Hash = string;
export type ExpirationDate = string;

export type Otp = {
  userId: UserId;
  verificationCode: VerificationCode;
  hash: Hash;
  expirationDate: ExpirationDate;
};

export function isOtpExpired(otp: Otp): boolean {
  const expiration = new Date(otp.expirationDate);
  return isNaN(expiration.getTime()) || expiration < new Date();
}

export function generateOtpExpirationDate(): ExpirationDate {
  const fiveMinutesInMilliseconds = 1000 * 60 * 5;
  return new Date(Date.now() + fiveMinutesInMilliseconds).toISOString();
}
</file>

<file path="src/auth/infrastructure/database/repositories/SQLiteTokenRepository.ts">
import db from '@common/infrastructure/database/dbClient';
import { TokenUser } from '@common/domain/model/TokenUser';
import { TokenRepository } from '../../../domain/interfaces/repositories/TokenRepository';
import { UserId } from '@common/domain/model/UserParameters';

export const tokenRepository: TokenRepository = {
  async saveToken(userId: UserId, token: TokenUser) {
    const existing = await db
      .selectFrom('token')
      .select('userId')
      .where('userId', '=', userId)
      .executeTakeFirst();

    if (existing) {
      await db
        .updateTable('token')
        .set({
          token,
        })
        .where('userId', '=', userId)
        .execute();
    } else {
      await db
        .insertInto('token')
        .values({
          userId,
          token,
        })
        .execute();
    }
  },
  async getUserIdByToken(token: TokenUser): Promise<UserId | null> {
    const row = await db
      .selectFrom('token')
      .select('userId')
      .where('token', '=', token)
      .executeTakeFirst();
    return row?.userId ?? null;
  },
};
</file>

<file path="src/auth/infrastructure/endpoints/requestOtp/__tests__/integration/requestOtp.test.ts">
import { build } from '@common/infrastructure/server/serverBuild';
import { REQUEST_OTP_ENDPOINT } from '../../requestOtp';
import { userRepository } from '@user/infrastructure/database/repositories/SQLiteUserRepository';
import { otpRepository } from '../../../../database/repositories/SQLiteOtpRepository';
import { codeGenerator } from '../../../../helpers/generators/randomCodeGenerator';
import { hashGenerator } from '../../../../helpers/generators/randomHashGenerator';
import { FastifyInstance } from 'fastify/types/instance';
import { phoneValidator } from '../../../../helpers/validators/blacklistPhoneValidator';
import { generateOtpExpirationDate } from '../../../../../domain/model/Otp';
import { initTestDatabase } from '@common/infrastructure/database/initTestDatabase';

jest.mock('../../../../../domain/model/Otp', () => ({
  ...jest.requireActual('../../../../../domain/model/Otp'),
  generateOtpExpirationDate: jest.fn(),
}));

describe('requestOtp', () => {
  let app: FastifyInstance;

  beforeAll(async () => {
    app = build();
    await app.ready();
    await initTestDatabase();
  });

  beforeEach(async () => {
    jest.resetAllMocks();
  });

  afterAll(async () => {
    await app.close();
  });

  test('should return hash and a verificationCode when introducing correct nin and phone number', async () => {
    const nin = '87654321Z';
    const phone = '222222222';
    const userId = 1;
    const hash = 'hash';
    const verificationCode = '123456';
    const expirationDate = new Date().toISOString();

    const saveOtpSpy = jest.spyOn(otpRepository, 'saveOtp').mockResolvedValue();
    jest.spyOn(userRepository, 'getUser').mockResolvedValue({
      id: userId,
      nin: nin,
      isBlocked: false,
    });

    (generateOtpExpirationDate as jest.Mock).mockReturnValue(expirationDate);
    jest.spyOn(codeGenerator, 'generateSixDigitCode').mockReturnValue(verificationCode);
    jest.spyOn(hashGenerator, 'generateHash').mockReturnValue(hash);

    const response = await app.inject({
      method: 'POST',
      url: REQUEST_OTP_ENDPOINT,
      payload: { nin: nin, phone: phone },
    });
    const data = response.json();

    expect(response.statusCode).toBe(201);
    expect(data).toHaveProperty('verificationCode');
    expect(data).toHaveProperty('hash');
    expect(data.hash).toBe(hash);
    expect(data.verificationCode).toBe(verificationCode);
    expect(saveOtpSpy).toHaveBeenCalledWith({ userId, verificationCode, hash, expirationDate });
  });

  test('should return missing nin or phone number error when introducing an empty nin', async () => {
    const nin = '';
    const phone = '222222222';

    const response = await app.inject({
      method: 'POST',
      url: REQUEST_OTP_ENDPOINT,
      payload: { nin: nin, phone: phone },
    });
    const data = response.json();

    expect(response.statusCode).toBe(400);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Missing nin or phone number.');
  });

  test('should return missing nin or phone number error when introducing an empty phone number', async () => {
    const nin = '87654321Z';
    const phone = '';

    const response = await app.inject({
      method: 'POST',
      url: REQUEST_OTP_ENDPOINT,
      payload: { nin: nin, phone: phone },
    });
    const data = response.json();

    expect(response.statusCode).toBe(400);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Missing nin or phone number.');
  });

  test('should return missing nin or phone number error when introducing no body', async () => {
    const response = await app.inject({
      method: 'POST',
      url: REQUEST_OTP_ENDPOINT,
      payload: {},
    });
    const data = response.json();

    expect(response.statusCode).toBe(400);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Missing nin or phone number.');
  });

  test('should return invalid nin or phone number error when nin has improper format', async () => {
    const nin = 'not a valid nin';
    const phone = '222222222';

    const response = await app.inject({
      method: 'POST',
      url: REQUEST_OTP_ENDPOINT,
      payload: { nin: nin, phone: phone },
    });
    const data = response.json();

    expect(response.statusCode).toBe(400);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Invalid nin or phone number.');
  });

  test('should return invalid nin or phone number error when phone number has improper format', async () => {
    const nin = '87654321Z';
    const phone = 'not a valid phone number';

    const response = await app.inject({
      method: 'POST',
      url: REQUEST_OTP_ENDPOINT,
      payload: { nin: nin, phone: phone },
    });
    const data = response.json();

    expect(response.statusCode).toBe(400);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Invalid nin or phone number.');
  });

  test('should return incorrect nin or phone number error when introducing incorrect parameters', async () => {
    const nin = '87654321Z';
    const phone = '213456789';

    jest.spyOn(userRepository, 'getUser').mockResolvedValue(null);

    const response = await app.inject({
      method: 'POST',
      url: REQUEST_OTP_ENDPOINT,
      payload: { nin: nin, phone: phone },
    });
    const data = response.json();

    expect(response.statusCode).toBe(401);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Incorrect nin or phone number.');
  });

  test('should return incorrect nin or phone number error when a sms cannot be sent to the phone number', async () => {
    const nin = '12312312Z';
    const phone = '222222222';
    const userId = 1;

    jest.spyOn(userRepository, 'getUser').mockResolvedValue({
      id: userId,
      nin: nin,
      isBlocked: false,
    });

    const blacklistPhoneValidatorSpy = jest
      .spyOn(phoneValidator, 'validatePhone')
      .mockReturnValue(false);

    const response = await app.inject({
      method: 'POST',
      url: REQUEST_OTP_ENDPOINT,
      payload: { nin: nin, phone: phone },
    });
    const data = response.json();

    expect(response.statusCode).toBe(401);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Incorrect nin or phone number.');
    expect(blacklistPhoneValidatorSpy).toHaveBeenCalledWith(phone);
  });

  test('should return user is blocked error when the user is blocked', async () => {
    const nin = '12312312Z';
    const phone = '222222222';
    const userId = 1;

    jest.spyOn(userRepository, 'getUser').mockResolvedValue({
      id: userId,
      nin: nin,
      isBlocked: true,
    });

    const response = await app.inject({
      method: 'POST',
      url: REQUEST_OTP_ENDPOINT,
      payload: { nin: nin, phone: phone },
    });
    const data = response.json();

    expect(response.statusCode).toBe(403);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('User is blocked.');
  });

  test('should return internal server error when the database malfunctions', async () => {
    const nin = '12312312Z';
    const phone = '222222222';

    jest.spyOn(userRepository, 'getUser').mockRejectedValue(new Error('Database error'));

    const response = await app.inject({
      method: 'POST',
      url: REQUEST_OTP_ENDPOINT,
      payload: { nin: nin, phone: phone },
    });
    const data = response.json();

    expect(response.statusCode).toBe(500);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Internal Server Error');
  });
  test('should return incorrect nin or phone number error when phone is not registered', async () => {
    const nin = '12345678A';
    const phone = '999999999';
    const userId = 1;

    jest.spyOn(userRepository, 'getUser').mockResolvedValue({
      id: userId,
      nin,
      isBlocked: false,
    });
    jest.spyOn(userRepository, 'isUserPhoneRegistered').mockResolvedValue(false);

    const response = await app.inject({
      method: 'POST',
      url: REQUEST_OTP_ENDPOINT,
      payload: { nin, phone },
    });

    const data = response.json();
    expect(response.statusCode).toBe(401);
    expect(data).toHaveProperty('error');
    expect(data.error).toBe('Incorrect nin or phone number.');
  });
});
</file>

<file path="src/auth/infrastructure/helpers/validators/blacklistPhoneValidator.ts">
import { PhoneValidator } from '../../../domain/interfaces/validators/PhoneValidator';
import { Phone } from '@common/domain/model/UserParameters';

const blacklistedPhones: Phone[] = ['111111111', '111111121', '666666668'];

export const phoneValidator: PhoneValidator = {
  validatePhone(phone: Phone): boolean {
    return !blacklistedPhones.includes(phone);
  },
};
</file>

<file path="src/common/infrastructure/database/schema.ts">
import { VerificationCode, Hash } from '@auth/domain/model/Otp';
import { TokenUser } from '../../domain/model/TokenUser';
import { UserId, Phone } from '../../domain/model/UserParameters';
import { UserAuth } from '@auth/domain/model/UserAuth';
import { Generated } from 'kysely';

export interface otpTable {
  userId: UserId;
  hash: Hash;
  verificationCode: VerificationCode;
  expirationDate: string;
}

export interface tokenTable {
  userId: UserId;
  token: TokenUser;
}

export interface userTable {
  id: Generated<number>;
  nin: UserAuth['nin'];
  isBlocked: boolean;
  fullName: string;
  email: string;
}

export interface phoneTable {
  id: Generated<number>;
  userId: UserId;
  phoneNumber: Phone;
}

export interface Database {
  otp: otpTable;
  token: tokenTable;
  user: userTable;
  phone: phoneTable;
}
</file>

<file path="src/user/infrastructure/endpoints/getProfile/getProfile.ts">
import { FastifyInstance } from 'fastify';
import {
  getProfileService,
  userNotFoundErrorStatusMsg,
} from '@user/application/services/getProfileService';
import { userRepository as defaultUserRepository } from '@user/infrastructure/database/repositories/SQLiteUserRepository';
import { getProfileSchema } from './schema';

export const GET_PROFILE_ENDPOINT = '/user/profile' as const;

const statusToMessage = {
  [userNotFoundErrorStatusMsg]: { error: 'User not found.' },
} as const;

const statusToCode = {
  SUCCESSFUL: 200 as const,
  [userNotFoundErrorStatusMsg]: 404 as const,
} as const;

interface Deps {
  userRepository: typeof defaultUserRepository;
}

export default function registerGetProfile(deps: Deps = { userRepository: defaultUserRepository }) {
  return async function (fastify: FastifyInstance) {
    fastify.get(GET_PROFILE_ENDPOINT, getProfileSchema, async (request, reply) => {
      try {
        const userId = request.userId!;
        const result = await getProfileService(deps.userRepository, { userId });

        if (typeof result !== 'object') {
          return reply.status(statusToCode[result]).send(statusToMessage[result]);
        }

        return reply.status(statusToCode.SUCCESSFUL).send(result);
      } catch (err) {
        request.log.error(err);
        return reply.status(500).send({ error: 'Internal Server Error' });
      }
    });
  };
}
</file>

<file path="jest.config.js">
/** @type {import('jest').Config} */
module.exports = {
  preset: 'ts-jest',
  runner: 'groups',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  moduleFileExtensions: ['ts', 'js', 'json', 'node'],
  testMatch: ['**/__tests__/**/*.(test|spec).ts', '**/?(*.)+(test|spec).ts'],
  clearMocks: true,
  forceExit: true,
  detectOpenHandles: true,
  testTimeout: 30000,
  transform: {
    '^.+\\.ts$': [
      'ts-jest',
      {
        tsconfig: './tsconfig.jest.json',
      },
    ],
  },
  moduleNameMapper: {
    '^@common/(.*)$': '<rootDir>/src/common/$1',
    '^@auth/(.*)$': '<rootDir>/src/auth/$1',
    '^@user/(.*)$': '<rootDir>/src/user/$1',
    '^@src/(.*)$': '<rootDir>/src/$1',
  },
  modulePaths: ['<rootDir>/src'],
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/**/index.ts',
    '!src/**/__tests__/**',
    '!src/**/*.spec.ts',
  ],
  coverageDirectory: 'coverage',
};
</file>

<file path="Makefile">
# Makefile for Sequra Backend

# Variables
DOCKER_COMPOSE = docker compose
DOCKER = docker

# Detect OS for cross-platform compatibility
ifeq ($(OS),Windows_NT)
    SHELL := cmd
    SLEEP := timeout /T
    READ := set /p
    VOLUME_NAME := sequra-backend-sm_sqlite_data
else
    SHELL := /bin/bash
    SLEEP := sleep
    READ := read
    VOLUME_NAME := sequra-backend-sm_sqlite_data
endif

# Default target
.DEFAULT_GOAL := help

# Help target
.PHONY: help
help: ## Show this help message
	@echo "Available commands:"
ifeq ($(OS),Windows_NT)
	@powershell -Command "Get-Content $(MAKEFILE_LIST) | Select-String '^[a-zA-Z_-]+:.*?##' | ForEach-Object { $$line = $$_.Line; if ($$line -match '^([a-zA-Z_-]+):.*?## (.+)') { Write-Host ('  ' + $$matches[1].PadRight(20) + ' ' + $$matches[2]) } }"
else
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "  %-20s %s\n", $$1, $$2}'
endif

# Docker commands
.PHONY: up
up: ## Start production/development services
	@echo "Starting production services..."
	$(DOCKER_COMPOSE) --profile production up -d

.PHONY: test
test: ## Run test services (uses in-memory database and closes when tests finish)
	@echo "Running tests..."
ifeq ($(OS),Windows_NT)
	set NODE_ENV=test&& set BACKEND_PORT=3001&& set BACKEND_COMMAND=npm run test&& $(DOCKER_COMPOSE) --profile test up -d --build
else
	NODE_ENV=test BACKEND_PORT=3001 BACKEND_COMMAND="npm run test" $(DOCKER_COMPOSE) --profile test up -d --build
endif
	@echo "Executing tests..."
	-$(DOCKER_COMPOSE) --profile test exec -e NODE_ENV=test -e BACKEND_PORT=3001 -e BACKEND_COMMAND="npm run test" backend sh -c "npm ci && npm run build && npm run test"
	@echo "Cleaning up test containers..."
	$(DOCKER_COMPOSE) --profile test down

.PHONY: test-watch
test-watch: ## Run tests in watch mode (uses in-memory database, stays open)
	@echo "Running tests in watch mode..."
ifeq ($(OS),Windows_NT)
	set NODE_ENV=test&& set BACKEND_PORT=3001&& set BACKEND_COMMAND=npm run test:watch&& $(DOCKER_COMPOSE) --profile test up -d --build
else
	NODE_ENV=test BACKEND_PORT=3001 BACKEND_COMMAND="npm run test:watch" $(DOCKER_COMPOSE) --profile test up -d --build
endif
	$(DOCKER_COMPOSE) --profile test exec -e NODE_ENV=test -e BACKEND_PORT=3001 -e BACKEND_COMMAND="npm run test:watch" backend sh -c "npm ci && npm run build && npm run test:watch"

.PHONY: up-test
up-test: ## Start test services in background (server stays running for manual testing)
	@echo "Starting test services..."
ifeq ($(OS),Windows_NT)
	set NODE_ENV=test&& set BACKEND_PORT=3001&& set BACKEND_COMMAND=npm start&& $(DOCKER_COMPOSE) --profile test up -d --build
else
	NODE_ENV=test BACKEND_PORT=3001 BACKEND_COMMAND="npm start" $(DOCKER_COMPOSE) --profile test up -d --build
endif
	@echo "Waiting for services to start..."
	$(SLEEP) 5
	@echo "Services should be running. Check with 'make logs-test' if there are issues."

.PHONY: down-test
down-test: ## Stop test services
	@echo "Stopping test services..."
	$(DOCKER_COMPOSE) --profile test down

.PHONY: logs-test
logs-test: ## Show logs from test services
	$(DOCKER_COMPOSE) --profile test logs -f

.PHONY: db-init
db-init: 
	@echo "Initializing production database..."
	$(DOCKER_COMPOSE) --profile production exec -e NODE_ENV=development -e DATABASE_FILE_PATH=./data/sequraBackendDB.sqlite backend sh -c "npx ts-node src/common/infrastructure/database/initDatabase.ts" ## Initialize production database (alias)

.PHONY: db-init-test
db-init-test: ## Initialize test database (in-memory)
	@echo "Initializing test database..."
	$(DOCKER_COMPOSE) --profile test exec -e NODE_ENV=test backend sh -c "npx ts-node src/common/infrastructure/database/initTestDatabase.ts"

.PHONY: down
down: ## Stop all services
	@echo "Stopping services..."
	$(DOCKER_COMPOSE) down

.PHONY: logs
logs: ## Show logs from all services
	$(DOCKER_COMPOSE) logs -f

.PHONY: shell
shell: ## Open shell in backend container (production)
	$(DOCKER_COMPOSE) --profile production exec -e NODE_ENV=development -e DATABASE_FILE_PATH=./data/sequraBackendDB.sqlite backend sh

.PHONY: shell-test
shell-test: ## Open shell in backend container (test)
	$(DOCKER_COMPOSE) --profile test exec -e NODE_ENV=test -e BACKEND_PORT=3001 backend sh

.PHONY: build
build: ## Build Docker images
	@echo "Building Docker images..."
	$(DOCKER_COMPOSE) build

.PHONY: clean
clean: ## Remove containers, networks, and volumes
	@echo "Cleaning up Docker resources..."
	$(DOCKER_COMPOSE) down -v --remove-orphans
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM"],
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "isolatedModules": true,
    "outDir": "dist",
    "rootDir": "src",
    "baseUrl": "./src",
    "paths": {
      "@common/*": ["common/*"],
      "@auth/*": ["auth/*"],
      "@user/*": ["user/*"],
      "@src/*": ["./*"]
    },
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "types": ["node", "jest"]
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="src/auth/application/services/__tests__/verifyOtpService.test.ts">
import { FastifyInstance } from 'fastify';
import { build } from '@common/infrastructure/server/serverBuild';
import { processOtpVerificationRequest } from '../verifyOtpService';
import { tokenRepository } from '../../../infrastructure/database/repositories/SQLiteTokenRepository';
import { otpRepository } from '../../../infrastructure/database/repositories/SQLiteOtpRepository';
import { TokenRepository } from '../../../domain/interfaces/repositories/TokenRepository';
import { OtpRepository } from '../../../domain/interfaces/repositories/OtpRepository';
import { TokenGenerator } from '../../../domain/interfaces/generators/TokenGenerator';
import { isOtpExpired } from '../../../domain/model/Otp';
import {
  expiredVerificationCodeErrorStatusMsg,
  otpNotFoundErrorStatusMsg,
} from '../../../domain/errors/otpLoginError';
import { tokenGenerator } from '../../../infrastructure/helpers/generators/fromHashTokenGenerator';

jest.mock('../../../domain/model/Otp', () => ({
  ...jest.requireActual('../../../domain/model/Otp'),
  isOtpExpired: jest.fn(),
}));

describe('verifyOtpService', () => {
  let app: FastifyInstance;

  beforeAll(async () => {
    app = build();
    await app.ready();
  });

  beforeEach(async () => {
    jest.resetAllMocks();
  });

  afterAll(async () => {
    await app.close();
  });

  test('should return a token when the otp is correct', async () => {
    const verificationCode = '123456';
    const hash = 'hash';
    const token = 'token';
    const otp = { userId: 1, verificationCode, hash, expirationDate: 'notExpiredDate' };

    const mockTokenRepository = {
      ...tokenRepository,
      saveToken: jest.fn(async () => {}),
    } as TokenRepository;
    const mockOtpRepository = {
      ...otpRepository,
      getOtp: jest.fn(async () => otp),
      deleteOtp: jest.fn(async () => {}),
    } as OtpRepository;
    const mockTokenGenerator = {
      generateToken: jest.fn(() => token),
    } as TokenGenerator;
    (isOtpExpired as jest.Mock).mockReturnValue(false);

    const serviceResponse = processOtpVerificationRequest(
      { ...mockTokenRepository },
      { ...mockOtpRepository },
      { ...mockTokenGenerator },
      { verificationCode, hash },
    );

    expect(serviceResponse).resolves.toEqual({ token });
  });

  test('should return an expired verification code error status message when the verification code is expired', async () => {
    const verificationCode = '123456';
    const hash = 'hash';
    const otp = { userId: 1, verificationCode, hash, expirationDate: 'notExpiredDate' };
    const mockOtpRepository = {
      ...otpRepository,
      getOtp: jest.fn(async () => otp),
      deleteOtp: jest.fn(async () => {}),
    } as OtpRepository;
    (isOtpExpired as jest.Mock).mockReturnValue(true);

    const serviceResponse = processOtpVerificationRequest(
      tokenRepository,
      { ...mockOtpRepository },
      tokenGenerator,
      { verificationCode, hash },
    );

    expect(serviceResponse).resolves.toEqual(expiredVerificationCodeErrorStatusMsg);
  });

  test('should return an otp not found error status message when the otp does not exist', async () => {
    const verificationCode = '123456';
    const hash = 'hash';
    const mockOtpRepository = {
      ...otpRepository,
      getOtp: jest.fn(async () => null),
    } as OtpRepository;

    const serviceResponse = processOtpVerificationRequest(
      tokenRepository,
      { ...mockOtpRepository },
      tokenGenerator,
      { verificationCode, hash },
    );

    expect(serviceResponse).resolves.toEqual(otpNotFoundErrorStatusMsg);
  });
});
</file>

<file path="src/auth/domain/interfaces/repositories/TokenRepository.ts">
import { TokenUser } from '@common/domain/model/TokenUser';
import { UserId } from '@common/domain/model/UserParameters';

export interface TokenRepository {
  saveToken(userId: UserId, token: TokenUser): Promise<void>;
  getUserIdByToken(token: TokenUser): Promise<UserId | null>;
}
</file>

<file path="src/auth/infrastructure/endpoints/verifyOtp/verifyOtp.ts">
import { FastifyInstance } from 'fastify';
import { verifyOtpSchema } from './schema';
import { TokenUser } from '@common/domain/model/TokenUser';
import {
  invalidHashOrCodeErrorStatusMsg,
  missingHashOrCodeErrorStatusMsg,
  VerifyOtpErrors,
} from './errors';
import {
  processOtpVerificationRequest,
  VerifyOtpServiceErrors,
} from '../../../application/services/verifyOtpService';
import { invalidHash } from '../../../domain/helpers/validators/hashValidator';
import { invalidVerificationCode } from '../../../domain/helpers/validators/verificationCodeValidator';
import { TokenRepository } from '../../../domain/interfaces/repositories/TokenRepository';
import { OtpRepository } from '../../../domain/interfaces/repositories/OtpRepository';
import { TokenGenerator } from '../../../domain/interfaces/generators/TokenGenerator';

export const VERIFY_OTP_ENDPOINT = '/auth/otp/verify';

const statusToMessage: { [K in VerifyOtpErrors]: string | object } = {
  MISSING_HASH_OR_CODE: { error: 'Missing hash or verification code.' },
  INVALID_HASH_OR_CODE: { error: 'Invalid hash or verification code.' },
  OTP_NOT_FOUND: { error: 'Incorrect hash or verification code.' },
  EXPIRED_VERIFICATION_CODE: { error: 'Incorrect hash or verification code.' },
};

type StatusCode = 201 | 400 | 401;

const statusToCode: { [K in VerifyOtpErrors]: StatusCode } & {
  [key: string]: StatusCode;
} = {
  SUCCESSFUL: 201,
  MISSING_HASH_OR_CODE: 400,
  INVALID_HASH_OR_CODE: 400,
  OTP_NOT_FOUND: 401,
  EXPIRED_VERIFICATION_CODE: 401,
};

type VerificationResponse = VerifyOtpErrors | { token: TokenUser };
type VerifyOtpBody = { hash: string; verificationCode: string };

interface VerifyOtpDependencies {
  tokenRepository: TokenRepository;
  otpRepository: OtpRepository;
  tokenGenerator: TokenGenerator;
}

function verifyOtp(dependencies: VerifyOtpDependencies) {
  return async function (fastify: FastifyInstance) {
    fastify.post(VERIFY_OTP_ENDPOINT, verifyOtpSchema, async (request, reply) => {
      try {
        const { hash, verificationCode } = request.body as VerifyOtpBody;

        if (missingParameters(hash, verificationCode)) {
          return reply
            .status(statusToCode[missingHashOrCodeErrorStatusMsg])
            .send(statusToMessage[missingHashOrCodeErrorStatusMsg]);
        }

        if (await invalidParameters(hash, verificationCode)) {
          return reply
            .status(statusToCode[invalidHashOrCodeErrorStatusMsg])
            .send(statusToMessage[invalidHashOrCodeErrorStatusMsg]);
        }

        const body = await processOtpVerificationRequest(
          dependencies.tokenRepository,
          dependencies.otpRepository,
          dependencies.tokenGenerator,
          { hash, verificationCode },
        );

        if (errorExists(body)) {
          return reply
            .status(statusToCode[body as VerifyOtpServiceErrors])
            .send(statusToMessage[body as VerifyOtpServiceErrors]);
        }

        return reply.status(statusToCode.SUCCESSFUL).send(body);
      } catch (error) {
        fastify.log.error(error);
        return reply.status(500).send({ error: 'Internal Server Error' });
      }
    });
  };
}

function errorExists(body: VerificationResponse): boolean {
  return typeof body !== 'object';
}

function missingParameters(hash: string, verificationCode: string): boolean {
  return !hash || !verificationCode;
}

async function invalidParameters(hash: string, verificationCode: string): Promise<boolean> {
  return invalidHash(hash) || invalidVerificationCode(verificationCode);
}

export default verifyOtp;
</file>

<file path="src/auth/application/services/verifyOtpService.ts">
import { isOtpExpired, Otp } from '../../domain/model/Otp';
import { TokenUser } from '../../../common/domain/model/TokenUser';
import { TokenRepository } from '../../domain/interfaces/repositories/TokenRepository';
import { UserId } from '@common/domain/model/UserParameters';
import { TokenGenerator } from '../../domain/interfaces/generators/TokenGenerator';
import { OtpRepository } from '../../domain/interfaces/repositories/OtpRepository';
import {
  ExpiredVerificationCodeError,
  expiredVerificationCodeErrorStatusMsg,
  OtpNotFoundError,
  otpNotFoundErrorStatusMsg,
} from '../../domain/errors/otpLoginError';

type VerifyOtpInput = Pick<Otp, 'verificationCode' | 'hash'>;
type VerifyOtpResponse = { token: TokenUser };

export type VerifyOtpServiceErrors = OtpNotFoundError | ExpiredVerificationCodeError;

export async function processOtpVerificationRequest(
  tokenRepository: TokenRepository,
  otpRepository: OtpRepository,
  tokenGenerator: TokenGenerator,
  input: VerifyOtpInput,
): Promise<VerifyOtpServiceErrors | VerifyOtpResponse> {
  const { verificationCode, hash } = input;
  const otp: Otp | null = await otpRepository.getOtp(verificationCode, hash);

  if (otpDoesntExist(otp)) {
    return otpNotFoundErrorStatusMsg;
  }

  const { userId } = otp;
  otpRepository.deleteOtp(userId);

  if (isOtpExpired(otp)) {
    return expiredVerificationCodeErrorStatusMsg;
  }

  const token: TokenUser = tokenGenerator.generateToken(hash);
  await saveToken(tokenRepository, userId, token);
  return { token };
}

async function saveToken(
  tokenRepository: TokenRepository,
  userId: UserId,
  token: TokenUser,
): Promise<void> {
  await tokenRepository.saveToken(userId, token);
}

function otpDoesntExist(otp: Otp | null): otp is null {
  return otp === null;
}
</file>

<file path="src/auth/infrastructure/endpoints/requestOtp/requestOtp.ts">
import { FastifyInstance } from 'fastify';
import { requestOtpSchema } from './schema';
import { isValidNin } from '../../../../common/domain/helpers/validators/ninValidator';
import { isValidPhone } from '../../../../common/domain/helpers/validators/phoneValidator';
import { processOtpRequest } from '../../../application/services/requestOtpService';
import {
  invalidNinOrPhoneErrorStatusMsg,
  missingNinOrPhoneErrorStatusMsg,
  RequestOtpErrors,
} from './errors';
import { OtpRepository } from '../../../domain/interfaces/repositories/OtpRepository';
import { UserRepository } from '@src/user/domain/interfaces/repositories/UserRespository';
import { CodeGenerator } from '../../../domain/interfaces/generators/CodeGenerator';
import { HashGenerator } from '../../../domain/interfaces/generators/HashGenerator';
import { PhoneValidator } from '../../../domain/interfaces/validators/PhoneValidator';

export const REQUEST_OTP_ENDPOINT = '/auth/otp';

const statusToMessage: { [K in RequestOtpErrors]: string | object } & {
  [key: string]: string | object;
} = {
  MISSING_NIN_OR_PHONE: { error: 'Missing nin or phone number.' },
  INVALID_NIN_OR_PHONE: { error: 'Invalid nin or phone number.' },
  UNAVAILABLE_PHONE: { error: 'Incorrect nin or phone number.' },
  USER_NOT_FOUND: { error: 'Incorrect nin or phone number.' },
  USER_BLOCKED: { error: 'User is blocked.' },
};

type StatusCode = 201 | 400 | 401 | 403;

const statusToCode: { [K in RequestOtpErrors]: StatusCode } & { [key: string]: StatusCode } = {
  SUCCESSFUL: 201,
  MISSING_NIN_OR_PHONE: 400,
  INVALID_NIN_OR_PHONE: 400,
  UNAVAILABLE_PHONE: 401,
  USER_NOT_FOUND: 401,
  USER_BLOCKED: 403,
};

type RequestOtpBody = { nin: string; phone: string };

interface RequestOtpDependencies {
  otpRepository: OtpRepository;
  userRepository: UserRepository;
  codeGenerator: CodeGenerator;
  hashGenerator: HashGenerator;
  phoneValidator: PhoneValidator;
}

function requestOtp(dependencies: RequestOtpDependencies) {
  return async function (fastify: FastifyInstance) {
    fastify.post(REQUEST_OTP_ENDPOINT, requestOtpSchema, async (request, reply) => {
      try {
        const { nin, phone } = request.body as RequestOtpBody;

        if (missingParameters(nin, phone)) {
          return reply
            .status(statusToCode[missingNinOrPhoneErrorStatusMsg])
            .send(statusToMessage[missingNinOrPhoneErrorStatusMsg]);
        }

        if (invalidParameters(nin, phone)) {
          return reply
            .status(statusToCode[invalidNinOrPhoneErrorStatusMsg])
            .send(statusToMessage[invalidNinOrPhoneErrorStatusMsg]);
        }

        const body = await processOtpRequest(
          dependencies.otpRepository,
          dependencies.userRepository,
          dependencies.codeGenerator,
          dependencies.hashGenerator,
          dependencies.phoneValidator,
          { nin, phone },
        );

        if (errorExists(body)) {
          return reply
            .status(statusToCode[body as RequestOtpErrors])
            .send(statusToMessage[body as RequestOtpErrors]);
        }

        return reply.status(statusToCode.SUCCESSFUL).send(body);
      } catch (error) {
        fastify.log.error(error);
        return reply.status(500).send({ error: 'Internal Server Error' });
      }
    });
  };
}

function errorExists(body: RequestOtpErrors | { hash: string; verificationCode: string }): boolean {
  return typeof body !== 'object';
}

function missingParameters(nin: string, phone: string): boolean {
  return !nin || !phone;
}

function invalidParameters(nin: string, phone: string): boolean {
  return !isValidNin(nin) || !isValidPhone(phone);
}

export default requestOtp;
</file>

<file path="src/auth/application/services/requestOtpService.ts">
import { Nin, Phone, UserId } from '@common/domain/model/UserParameters';
import { UserAuth } from '@auth/domain/model/UserAuth';
import {
  UserBlockedError,
  userBlockedErrorStatusMsg,
  UserNotFoundError,
  userNotFoundErrorStatusMsg,
  UserPhoneUnavailableError,
  userPhoneUnavailableForSmsErrorStatusMsg,
} from '../../domain/errors/userLoginErrors';
import { OtpRepository } from '../../domain/interfaces/repositories/OtpRepository';
import { UserRepository } from '@src/user/domain/interfaces/repositories/UserRespository';
import { CodeGenerator } from '../../domain/interfaces/generators/CodeGenerator';
import { HashGenerator } from '../../domain/interfaces/generators/HashGenerator';
import {
  ExpirationDate,
  generateOtpExpirationDate,
  Hash,
  Otp,
  VerificationCode,
} from '../../domain/model/Otp';
import { PhoneValidator } from '../../domain/interfaces/validators/PhoneValidator';

type RequestOtpInput = {
  nin: Nin;
  phone: Phone;
};
type RequestOtpResponse = Pick<Otp, 'hash' | 'verificationCode'>;

export type RequestOtpServiceErrors =
  | UserPhoneUnavailableError
  | UserBlockedError
  | UserNotFoundError;

export async function processOtpRequest(
  otpRepository: OtpRepository,
  userRepository: UserRepository,
  codeGenerator: CodeGenerator,
  hashGenerator: HashGenerator,
  phoneValidator: PhoneValidator,
  input: RequestOtpInput,
): Promise<RequestOtpServiceErrors | RequestOtpResponse> {
  const { nin, phone } = input;
  const user: UserAuth | null = await userRepository.getUser(nin);

  if (userDoesntExist(user)) {
    return userNotFoundErrorStatusMsg;
  }

  const { id: userId } = user;
  if (userIsBlocked(user)) {
    return userBlockedErrorStatusMsg;
  }
  const userPhoneExist: boolean = await userRepository.isUserPhoneRegistered(user.id, phone);

  if (userPhoneDoesNotExist(userPhoneExist)) {
    return userNotFoundErrorStatusMsg;
  }
  if (userPhoneUnavailable(phoneValidator, phone)) {
    return userPhoneUnavailableForSmsErrorStatusMsg;
  }

  return getOtp(otpRepository, codeGenerator, hashGenerator, userId);
}

async function getOtp(
  otpRepository: OtpRepository,
  codeGenerator: CodeGenerator,
  hashGenerator: HashGenerator,
  userId: UserId,
): Promise<RequestOtpResponse> {
  const otp: Otp = generateOtp(userId, codeGenerator, hashGenerator);
  otpRepository.saveOtp(otp);

  const { hash, verificationCode } = otp;
  return { hash, verificationCode };
}

function userPhoneDoesNotExist(userPhoneExist: boolean): boolean {
  return !userPhoneExist;
}

function userPhoneUnavailable(phoneValidator: PhoneValidator, phone: Phone) {
  return !phoneValidator.validatePhone(phone);
}

function generateOtp(
  userId: UserId,
  codeGenerator: CodeGenerator,
  hashGenerator: HashGenerator,
): Otp {
  const hash: Hash = hashGenerator.generateHash();
  const verificationCode: VerificationCode = codeGenerator.generateSixDigitCode();
  const expirationDateString: ExpirationDate = generateOtpExpirationDate();
  const otp: Otp = { userId, hash, verificationCode, expirationDate: expirationDateString };
  return otp;
}

export function userDoesntExist(user: UserAuth | null): user is null {
  return user === null;
}

export function userIsBlocked(user: UserAuth): boolean {
  return user.isBlocked;
}
</file>

<file path="package.json">
{
  "name": "sequra-backend",
  "version": "1.0.0",
  "description": "",
  "main": "dist/common/infrastructure/server/index.js",
  "scripts": {
    "dev": "nodemon --ext ts,tsx --watch src --exec \"ts-node -r tsconfig-paths/register src/common/infrastructure/server/index.ts\"",
    "build": "tsc --project tsconfig.build.json",
    "start": "node -r tsconfig-paths/register dist/common/infrastructure/server/index.js",
    "test": "cross-env NODE_ENV=test jest --passWithNoTests",
    "test:watch": "cross-env NODE_ENV=test jest --watchAll --passWithNoTests",
    "test:coverage": "cross-env NODE_ENV=test jest --coverage",
    "seed:user": "ts-node src/common/infrastructure/database/seeders/userSeeder.ts"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "devDependencies": {
    "@commitlint/cli": "^19.8.1",
    "@commitlint/config-conventional": "^19.8.1",
    "@types/better-sqlite3": "^7.6.13",
    "@types/jest": "^30.0.0",
    "@types/node": "^24.0.12",
    "@types/supertest": "^6.0.3",
    "@typescript-eslint/eslint-plugin": "^8.39.0",
    "@typescript-eslint/parser": "^8.39.0",
    "cross-env": "^10.0.0",
    "dotenv": "^17.2.1",
    "eslint": "^9.31.0",
    "eslint-plugin-unused-imports": "^4.1.4",
    "husky": "^9.1.7",
    "jest": "^30.0.5",
    "jest-runner-groups": "^2.2.0",
    "lint-staged": "^16.1.4",
    "msw": "^2.10.4",
    "prettier": "^3.6.2",
    "supertest": "^7.1.3",
    "ts-jest": "^29.4.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.8.3",
    "typescript-eslint": "^8.39.0"
  },
  "dependencies": {
    "@fastify/swagger": "^9.5.1",
    "@fastify/swagger-ui": "^5.2.3",
    "axios": "^1.6.8",
    "better-sqlite3": "^12.2.0",
    "drizzle-orm": "^0.44.4",
    "fastify": "^5.4.0",
    "fastify-plugin": "^5.0.1",
    "kysely": "^0.28.3",
    "nodemon": "^3.1.10",
    "pino-pretty": "^13.0.0",
    "tsconfig-paths": "^4.2.0"
  },
  "lint-staged": {
    "*.{ts,tsx,js,jsx}": [
      "eslint --fix",
      "prettier --write",
      "cross-env NODE_ENV=test jest --bail --passWithNoTests --findRelatedTests"
    ],
    "*.{json,md,yml}": [
      "prettier --write"
    ]
  }
}
</file>

<file path="src/auth/application/services/__tests__/requestOtpService.test.ts">
import { processOtpRequest } from '../requestOtpService';
import { UserRepository } from '@user/domain/interfaces/repositories/UserRespository';
import {
  userBlockedErrorStatusMsg,
  userNotFoundErrorStatusMsg,
  userPhoneUnavailableForSmsErrorStatusMsg,
} from '../../../domain/errors/userLoginErrors';
import { PhoneValidator } from '../../../domain/interfaces/validators/PhoneValidator';
import { CodeGenerator } from '../../../domain/interfaces/generators/CodeGenerator';
import { HashGenerator } from '../../../domain/interfaces/generators/HashGenerator';
import { OtpRepository } from '../../../domain/interfaces/repositories/OtpRepository';
import { UserAuth } from '../../../domain/model/UserAuth';

describe('requestOtpService', () => {
  beforeEach(() => {
    jest.resetAllMocks();
  });

  test('should return a hash and a verification code when the user is correct', async () => {
    const nin = 'userNin';
    const phone = 'userPhone';
    const verificationCode = '123456';
    const hash = 'hash';
    const user: UserAuth = { id: 1, nin, isBlocked: false };

    const mockUserRepository: UserRepository = {
      getUser: jest.fn(async () => user),
      isUserPhoneRegistered: jest.fn(async (userId, inputPhone) => {
        return userId === user.id && inputPhone === phone;
      }),
      getProfile: jest.fn(),
    };

    const mockOtpRepository: OtpRepository = {
      saveOtp: jest.fn(async () => {}),
      getOtp: jest.fn(),
      deleteOtp: jest.fn(),
    };

    const mockCodeGenerator: CodeGenerator = {
      generateSixDigitCode: jest.fn(() => verificationCode),
    };

    const mockHashGenerator: HashGenerator = {
      generateHash: jest.fn(() => hash),
    };

    const mockPhoneValidator: PhoneValidator = {
      validatePhone: jest.fn(() => true),
    };

    await expect(
      processOtpRequest(
        mockOtpRepository,
        mockUserRepository,
        mockCodeGenerator,
        mockHashGenerator,
        mockPhoneValidator,
        { nin, phone },
      ),
    ).resolves.toEqual({ hash, verificationCode });

    expect(mockOtpRepository.saveOtp).toHaveBeenCalledTimes(1);
  });

  test('should return a user not found error status message when the user does not exist', async () => {
    const nin = 'nonExistingNin';
    const phone = 'nonExistingPhone';

    const mockUserRepository: UserRepository = {
      getUser: jest.fn(async () => null),
      isUserPhoneRegistered: jest.fn(),
      getProfile: jest.fn(),
    };

    const mockOtpRepository: OtpRepository = {
      saveOtp: jest.fn(),
      getOtp: jest.fn(),
      deleteOtp: jest.fn(),
    };

    const mockCodeGenerator: CodeGenerator = { generateSixDigitCode: jest.fn() };
    const mockHashGenerator: HashGenerator = { generateHash: jest.fn() };
    const mockPhoneValidator: PhoneValidator = { validatePhone: jest.fn() };

    await expect(
      processOtpRequest(
        mockOtpRepository,
        mockUserRepository,
        mockCodeGenerator,
        mockHashGenerator,
        mockPhoneValidator,
        { nin, phone },
      ),
    ).resolves.toEqual(userNotFoundErrorStatusMsg);
  });

  test('should return a user blocked error status message when the user is blocked', async () => {
    const nin = 'userBlockedNin';
    const phone = 'userBlockedPhone';
    const blockedUser: UserAuth = { id: 1, nin, isBlocked: true };

    const mockUserRepository: UserRepository = {
      getUser: jest.fn(async () => blockedUser),
      isUserPhoneRegistered: jest.fn(),
      getProfile: jest.fn(),
    };

    const mockOtpRepository: OtpRepository = {
      saveOtp: jest.fn(),
      getOtp: jest.fn(),
      deleteOtp: jest.fn(),
    };

    const mockCodeGenerator: CodeGenerator = { generateSixDigitCode: jest.fn() };
    const mockHashGenerator: HashGenerator = { generateHash: jest.fn() };
    const mockPhoneValidator: PhoneValidator = { validatePhone: jest.fn() };

    await expect(
      processOtpRequest(
        mockOtpRepository,
        mockUserRepository,
        mockCodeGenerator,
        mockHashGenerator,
        mockPhoneValidator,
        { nin, phone },
      ),
    ).resolves.toEqual(userBlockedErrorStatusMsg);
  });

  test('should return a user phone unavailable for sms error status message when the user phone is unavailable to be sent an sms', async () => {
    const nin = 'userNin';
    const phone = 'unavailablePhone';
    const user: UserAuth = { id: 1, nin, isBlocked: false };

    const mockUserRepository: UserRepository = {
      getUser: jest.fn(async () => user),
      isUserPhoneRegistered: jest.fn(async () => true),
      getProfile: jest.fn(),
    };

    const mockPhoneValidator: PhoneValidator = {
      validatePhone: jest.fn(() => false),
    };

    const mockOtpRepository: OtpRepository = {
      saveOtp: jest.fn(),
      getOtp: jest.fn(),
      deleteOtp: jest.fn(),
    };

    const mockCodeGenerator: CodeGenerator = { generateSixDigitCode: jest.fn() };
    const mockHashGenerator: HashGenerator = { generateHash: jest.fn() };

    const serviceResponse = await processOtpRequest(
      mockOtpRepository,
      mockUserRepository,
      mockCodeGenerator,
      mockHashGenerator,
      mockPhoneValidator,
      { nin, phone },
    );

    expect(serviceResponse).toEqual(userPhoneUnavailableForSmsErrorStatusMsg);
  });
});
</file>

</files>
